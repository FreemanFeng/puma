// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// source: gdt.go
// DO NOT EDIT!

package gdt

import (
	"bytes"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

func (mj *AdcreativeElementsType) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *AdcreativeElementsType) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"image":`)
	fflib.WriteJsonString(buf, string(mj.Image))
	buf.WriteString(`,"image2":`)
	fflib.WriteJsonString(buf, string(mj.Image2))
	buf.WriteString(`,"image3":`)
	fflib.WriteJsonString(buf, string(mj.Image3))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(mj.Title))
	buf.WriteString(`,"description":`)
	fflib.WriteJsonString(buf, string(mj.Description))
	buf.WriteString(`,"corporate":`)

	{

		err = mj.Corporate.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"deep_link":`)
	fflib.WriteJsonString(buf, string(mj.DeepLink))
	buf.WriteString(`,"phone":`)
	fflib.WriteJsonString(buf, string(mj.Phone))
	buf.WriteString(`,"video":`)
	fflib.WriteJsonString(buf, string(mj.Video))
	buf.WriteString(`,"caption":`)
	fflib.WriteJsonString(buf, string(mj.Caption))
	buf.WriteString(`,"image_list":`)
	if mj.ImageList != nil {
		buf.WriteString(`[`)
		for i, v := range mj.ImageList {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"element_story":`)
	if mj.ElementStory != nil {
		buf.WriteString(`[`)
		for i, v := range mj.ElementStory {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"multi_share_optimized":`)
	fflib.WriteJsonString(buf, string(mj.MultiShareOptimized))
	buf.WriteString(`,"url":`)
	fflib.WriteJsonString(buf, string(mj.Url))
	buf.WriteString(`,"button_text":`)
	fflib.WriteJsonString(buf, string(mj.ButtonText))
	buf.WriteString(`,"video_popup_url":`)
	fflib.WriteJsonString(buf, string(mj.VideoPopupUrl))
	buf.WriteString(`,"video_popup_button":`)

	{

		err = mj.VideoPopupButton.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"image2_url":`)
	fflib.WriteJsonString(buf, string(mj.Image2Url))
	buf.WriteString(`,"image3_url":`)
	fflib.WriteJsonString(buf, string(mj.Image3Url))
	buf.WriteString(`,"image_list_url":`)
	if mj.ImageListUrl != nil {
		buf.WriteString(`[`)
		for i, v := range mj.ImageListUrl {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"video_url":`)
	fflib.WriteJsonString(buf, string(mj.VideoUrl))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_AdcreativeElementsTypebase = iota
	ffj_t_AdcreativeElementsTypeno_such_key

	ffj_t_AdcreativeElementsType_Image

	ffj_t_AdcreativeElementsType_Image2

	ffj_t_AdcreativeElementsType_Image3

	ffj_t_AdcreativeElementsType_Title

	ffj_t_AdcreativeElementsType_Description

	ffj_t_AdcreativeElementsType_Corporate

	ffj_t_AdcreativeElementsType_DeepLink

	ffj_t_AdcreativeElementsType_Phone

	ffj_t_AdcreativeElementsType_Video

	ffj_t_AdcreativeElementsType_Caption

	ffj_t_AdcreativeElementsType_ImageList

	ffj_t_AdcreativeElementsType_ElementStory

	ffj_t_AdcreativeElementsType_MultiShareOptimized

	ffj_t_AdcreativeElementsType_Url

	ffj_t_AdcreativeElementsType_ButtonText

	ffj_t_AdcreativeElementsType_VideoPopupUrl

	ffj_t_AdcreativeElementsType_VideoPopupButton

	ffj_t_AdcreativeElementsType_Image2Url

	ffj_t_AdcreativeElementsType_Image3Url

	ffj_t_AdcreativeElementsType_ImageListUrl

	ffj_t_AdcreativeElementsType_VideoUrl
)

var ffj_key_AdcreativeElementsType_Image = []byte("image")

var ffj_key_AdcreativeElementsType_Image2 = []byte("image2")

var ffj_key_AdcreativeElementsType_Image3 = []byte("image3")

var ffj_key_AdcreativeElementsType_Title = []byte("title")

var ffj_key_AdcreativeElementsType_Description = []byte("description")

var ffj_key_AdcreativeElementsType_Corporate = []byte("corporate")

var ffj_key_AdcreativeElementsType_DeepLink = []byte("deep_link")

var ffj_key_AdcreativeElementsType_Phone = []byte("phone")

var ffj_key_AdcreativeElementsType_Video = []byte("video")

var ffj_key_AdcreativeElementsType_Caption = []byte("caption")

var ffj_key_AdcreativeElementsType_ImageList = []byte("image_list")

var ffj_key_AdcreativeElementsType_ElementStory = []byte("element_story")

var ffj_key_AdcreativeElementsType_MultiShareOptimized = []byte("multi_share_optimized")

var ffj_key_AdcreativeElementsType_Url = []byte("url")

var ffj_key_AdcreativeElementsType_ButtonText = []byte("button_text")

var ffj_key_AdcreativeElementsType_VideoPopupUrl = []byte("video_popup_url")

var ffj_key_AdcreativeElementsType_VideoPopupButton = []byte("video_popup_button")

var ffj_key_AdcreativeElementsType_Image2Url = []byte("image2_url")

var ffj_key_AdcreativeElementsType_Image3Url = []byte("image3_url")

var ffj_key_AdcreativeElementsType_ImageListUrl = []byte("image_list_url")

var ffj_key_AdcreativeElementsType_VideoUrl = []byte("video_url")

func (uj *AdcreativeElementsType) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *AdcreativeElementsType) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_AdcreativeElementsTypebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_AdcreativeElementsTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffj_key_AdcreativeElementsType_ButtonText, kn) {
						currentKey = ffj_t_AdcreativeElementsType_ButtonText
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_AdcreativeElementsType_Corporate, kn) {
						currentKey = ffj_t_AdcreativeElementsType_Corporate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdcreativeElementsType_Caption, kn) {
						currentKey = ffj_t_AdcreativeElementsType_Caption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_AdcreativeElementsType_Description, kn) {
						currentKey = ffj_t_AdcreativeElementsType_Description
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdcreativeElementsType_DeepLink, kn) {
						currentKey = ffj_t_AdcreativeElementsType_DeepLink
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_AdcreativeElementsType_ElementStory, kn) {
						currentKey = ffj_t_AdcreativeElementsType_ElementStory
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_AdcreativeElementsType_Image, kn) {
						currentKey = ffj_t_AdcreativeElementsType_Image
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdcreativeElementsType_Image2, kn) {
						currentKey = ffj_t_AdcreativeElementsType_Image2
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdcreativeElementsType_Image3, kn) {
						currentKey = ffj_t_AdcreativeElementsType_Image3
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdcreativeElementsType_ImageList, kn) {
						currentKey = ffj_t_AdcreativeElementsType_ImageList
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdcreativeElementsType_Image2Url, kn) {
						currentKey = ffj_t_AdcreativeElementsType_Image2Url
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdcreativeElementsType_Image3Url, kn) {
						currentKey = ffj_t_AdcreativeElementsType_Image3Url
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdcreativeElementsType_ImageListUrl, kn) {
						currentKey = ffj_t_AdcreativeElementsType_ImageListUrl
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_AdcreativeElementsType_MultiShareOptimized, kn) {
						currentKey = ffj_t_AdcreativeElementsType_MultiShareOptimized
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_AdcreativeElementsType_Phone, kn) {
						currentKey = ffj_t_AdcreativeElementsType_Phone
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_AdcreativeElementsType_Title, kn) {
						currentKey = ffj_t_AdcreativeElementsType_Title
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_AdcreativeElementsType_Url, kn) {
						currentKey = ffj_t_AdcreativeElementsType_Url
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_AdcreativeElementsType_Video, kn) {
						currentKey = ffj_t_AdcreativeElementsType_Video
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdcreativeElementsType_VideoPopupUrl, kn) {
						currentKey = ffj_t_AdcreativeElementsType_VideoPopupUrl
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdcreativeElementsType_VideoPopupButton, kn) {
						currentKey = ffj_t_AdcreativeElementsType_VideoPopupButton
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdcreativeElementsType_VideoUrl, kn) {
						currentKey = ffj_t_AdcreativeElementsType_VideoUrl
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_AdcreativeElementsType_VideoUrl, kn) {
					currentKey = ffj_t_AdcreativeElementsType_VideoUrl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdcreativeElementsType_ImageListUrl, kn) {
					currentKey = ffj_t_AdcreativeElementsType_ImageListUrl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdcreativeElementsType_Image3Url, kn) {
					currentKey = ffj_t_AdcreativeElementsType_Image3Url
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdcreativeElementsType_Image2Url, kn) {
					currentKey = ffj_t_AdcreativeElementsType_Image2Url
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdcreativeElementsType_VideoPopupButton, kn) {
					currentKey = ffj_t_AdcreativeElementsType_VideoPopupButton
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdcreativeElementsType_VideoPopupUrl, kn) {
					currentKey = ffj_t_AdcreativeElementsType_VideoPopupUrl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdcreativeElementsType_ButtonText, kn) {
					currentKey = ffj_t_AdcreativeElementsType_ButtonText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AdcreativeElementsType_Url, kn) {
					currentKey = ffj_t_AdcreativeElementsType_Url
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdcreativeElementsType_MultiShareOptimized, kn) {
					currentKey = ffj_t_AdcreativeElementsType_MultiShareOptimized
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdcreativeElementsType_ElementStory, kn) {
					currentKey = ffj_t_AdcreativeElementsType_ElementStory
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdcreativeElementsType_ImageList, kn) {
					currentKey = ffj_t_AdcreativeElementsType_ImageList
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AdcreativeElementsType_Caption, kn) {
					currentKey = ffj_t_AdcreativeElementsType_Caption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AdcreativeElementsType_Video, kn) {
					currentKey = ffj_t_AdcreativeElementsType_Video
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AdcreativeElementsType_Phone, kn) {
					currentKey = ffj_t_AdcreativeElementsType_Phone
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdcreativeElementsType_DeepLink, kn) {
					currentKey = ffj_t_AdcreativeElementsType_DeepLink
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AdcreativeElementsType_Corporate, kn) {
					currentKey = ffj_t_AdcreativeElementsType_Corporate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdcreativeElementsType_Description, kn) {
					currentKey = ffj_t_AdcreativeElementsType_Description
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AdcreativeElementsType_Title, kn) {
					currentKey = ffj_t_AdcreativeElementsType_Title
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdcreativeElementsType_Image3, kn) {
					currentKey = ffj_t_AdcreativeElementsType_Image3
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdcreativeElementsType_Image2, kn) {
					currentKey = ffj_t_AdcreativeElementsType_Image2
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AdcreativeElementsType_Image, kn) {
					currentKey = ffj_t_AdcreativeElementsType_Image
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_AdcreativeElementsTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_AdcreativeElementsType_Image:
					goto handle_Image

				case ffj_t_AdcreativeElementsType_Image2:
					goto handle_Image2

				case ffj_t_AdcreativeElementsType_Image3:
					goto handle_Image3

				case ffj_t_AdcreativeElementsType_Title:
					goto handle_Title

				case ffj_t_AdcreativeElementsType_Description:
					goto handle_Description

				case ffj_t_AdcreativeElementsType_Corporate:
					goto handle_Corporate

				case ffj_t_AdcreativeElementsType_DeepLink:
					goto handle_DeepLink

				case ffj_t_AdcreativeElementsType_Phone:
					goto handle_Phone

				case ffj_t_AdcreativeElementsType_Video:
					goto handle_Video

				case ffj_t_AdcreativeElementsType_Caption:
					goto handle_Caption

				case ffj_t_AdcreativeElementsType_ImageList:
					goto handle_ImageList

				case ffj_t_AdcreativeElementsType_ElementStory:
					goto handle_ElementStory

				case ffj_t_AdcreativeElementsType_MultiShareOptimized:
					goto handle_MultiShareOptimized

				case ffj_t_AdcreativeElementsType_Url:
					goto handle_Url

				case ffj_t_AdcreativeElementsType_ButtonText:
					goto handle_ButtonText

				case ffj_t_AdcreativeElementsType_VideoPopupUrl:
					goto handle_VideoPopupUrl

				case ffj_t_AdcreativeElementsType_VideoPopupButton:
					goto handle_VideoPopupButton

				case ffj_t_AdcreativeElementsType_Image2Url:
					goto handle_Image2Url

				case ffj_t_AdcreativeElementsType_Image3Url:
					goto handle_Image3Url

				case ffj_t_AdcreativeElementsType_ImageListUrl:
					goto handle_ImageListUrl

				case ffj_t_AdcreativeElementsType_VideoUrl:
					goto handle_VideoUrl

				case ffj_t_AdcreativeElementsTypeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Image:

	/* handler: uj.Image type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Image = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Image2:

	/* handler: uj.Image2 type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Image2 = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Image3:

	/* handler: uj.Image3 type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Image3 = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: uj.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: uj.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Corporate:

	/* handler: uj.Corporate type=gdt.CorporateType kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Corporate.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DeepLink:

	/* handler: uj.DeepLink type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.DeepLink = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Phone:

	/* handler: uj.Phone type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Phone = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Video:

	/* handler: uj.Video type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Video = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: uj.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageList:

	/* handler: uj.ImageList type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.ImageList = nil
		} else {

			uj.ImageList = []string{}

			wantVal := true

			for {

				var tmp_uj__ImageList string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__ImageList type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__ImageList = string(string(outBuf))

					}
				}

				uj.ImageList = append(uj.ImageList, tmp_uj__ImageList)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ElementStory:

	/* handler: uj.ElementStory type=[]gdt.ElementStoryItemType kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.ElementStory = nil
		} else {

			uj.ElementStory = []ElementStoryItemType{}

			wantVal := true

			for {

				var tmp_uj__ElementStory ElementStoryItemType

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__ElementStory type=gdt.ElementStoryItemType kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__ElementStory.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.ElementStory = append(uj.ElementStory, tmp_uj__ElementStory)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MultiShareOptimized:

	/* handler: uj.MultiShareOptimized type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.MultiShareOptimized = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Url:

	/* handler: uj.Url type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Url = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ButtonText:

	/* handler: uj.ButtonText type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ButtonText = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoPopupUrl:

	/* handler: uj.VideoPopupUrl type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.VideoPopupUrl = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoPopupButton:

	/* handler: uj.VideoPopupButton type=gdt.VideoPopupButtonType kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.VideoPopupButton.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Image2Url:

	/* handler: uj.Image2Url type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Image2Url = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Image3Url:

	/* handler: uj.Image3Url type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Image3Url = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageListUrl:

	/* handler: uj.ImageListUrl type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.ImageListUrl = nil
		} else {

			uj.ImageListUrl = []string{}

			wantVal := true

			for {

				var tmp_uj__ImageListUrl string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__ImageListUrl type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__ImageListUrl = string(string(outBuf))

					}
				}

				uj.ImageListUrl = append(uj.ImageListUrl, tmp_uj__ImageListUrl)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoUrl:

	/* handler: uj.VideoUrl type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.VideoUrl = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *AdcreativeGetData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *AdcreativeGetData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"list":`)
	if mj.List != nil {
		buf.WriteString(`[`)
		for i, v := range mj.List {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"page_info":`)

	{

		err = mj.PageInfo.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_AdcreativeGetDatabase = iota
	ffj_t_AdcreativeGetDatano_such_key

	ffj_t_AdcreativeGetData_List

	ffj_t_AdcreativeGetData_PageInfo
)

var ffj_key_AdcreativeGetData_List = []byte("list")

var ffj_key_AdcreativeGetData_PageInfo = []byte("page_info")

func (uj *AdcreativeGetData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *AdcreativeGetData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_AdcreativeGetDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_AdcreativeGetDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_AdcreativeGetData_List, kn) {
						currentKey = ffj_t_AdcreativeGetData_List
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_AdcreativeGetData_PageInfo, kn) {
						currentKey = ffj_t_AdcreativeGetData_PageInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_AdcreativeGetData_PageInfo, kn) {
					currentKey = ffj_t_AdcreativeGetData_PageInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdcreativeGetData_List, kn) {
					currentKey = ffj_t_AdcreativeGetData_List
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_AdcreativeGetDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_AdcreativeGetData_List:
					goto handle_List

				case ffj_t_AdcreativeGetData_PageInfo:
					goto handle_PageInfo

				case ffj_t_AdcreativeGetDatano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_List:

	/* handler: uj.List type=[]gdt.AdcreativeGetDataList kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.List = nil
		} else {

			uj.List = []AdcreativeGetDataList{}

			wantVal := true

			for {

				var tmp_uj__List AdcreativeGetDataList

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__List type=gdt.AdcreativeGetDataList kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__List.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.List = append(uj.List, tmp_uj__List)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PageInfo:

	/* handler: uj.PageInfo type=gdt.PageInfoData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.PageInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *AdcreativeGetDataList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *AdcreativeGetDataList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"campaign_id":`)
	fflib.FormatBits2(buf, uint64(mj.CampaignID), 10, mj.CampaignID < 0)
	buf.WriteString(`,"adcreative_id":`)
	fflib.FormatBits2(buf, uint64(mj.AdcreativeID), 10, mj.AdcreativeID < 0)
	buf.WriteString(`,"adcreative_name":`)
	fflib.WriteJsonString(buf, string(mj.AdcreativeName))
	buf.WriteString(`,"adcreative_template_id":`)
	fflib.FormatBits2(buf, uint64(mj.AdcreativeTemplateID), 10, mj.AdcreativeTemplateID < 0)
	buf.WriteString(`,"adcreative_elements":`)

	{

		err = mj.AdcreativeElements.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"destination_url":`)
	fflib.WriteJsonString(buf, string(mj.DestinationUrl))
	buf.WriteString(`,"site_set":`)
	if mj.SiteSet != nil {
		buf.WriteString(`[`)
		for i, v := range mj.SiteSet {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"product_type":`)
	fflib.WriteJsonString(buf, string(mj.ProductType))
	buf.WriteString(`,"product_refs_id":`)
	fflib.WriteJsonString(buf, string(mj.ProductRefsID))
	buf.WriteString(`,"created_time":`)
	fflib.FormatBits2(buf, uint64(mj.CreatedTime), 10, mj.CreatedTime < 0)
	buf.WriteString(`,"last_modified_time":`)
	fflib.FormatBits2(buf, uint64(mj.LastModifiedTime), 10, mj.LastModifiedTime < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_AdcreativeGetDataListbase = iota
	ffj_t_AdcreativeGetDataListno_such_key

	ffj_t_AdcreativeGetDataList_CampaignID

	ffj_t_AdcreativeGetDataList_AdcreativeID

	ffj_t_AdcreativeGetDataList_AdcreativeName

	ffj_t_AdcreativeGetDataList_AdcreativeTemplateID

	ffj_t_AdcreativeGetDataList_AdcreativeElements

	ffj_t_AdcreativeGetDataList_DestinationUrl

	ffj_t_AdcreativeGetDataList_SiteSet

	ffj_t_AdcreativeGetDataList_ProductType

	ffj_t_AdcreativeGetDataList_ProductRefsID

	ffj_t_AdcreativeGetDataList_CreatedTime

	ffj_t_AdcreativeGetDataList_LastModifiedTime
)

var ffj_key_AdcreativeGetDataList_CampaignID = []byte("campaign_id")

var ffj_key_AdcreativeGetDataList_AdcreativeID = []byte("adcreative_id")

var ffj_key_AdcreativeGetDataList_AdcreativeName = []byte("adcreative_name")

var ffj_key_AdcreativeGetDataList_AdcreativeTemplateID = []byte("adcreative_template_id")

var ffj_key_AdcreativeGetDataList_AdcreativeElements = []byte("adcreative_elements")

var ffj_key_AdcreativeGetDataList_DestinationUrl = []byte("destination_url")

var ffj_key_AdcreativeGetDataList_SiteSet = []byte("site_set")

var ffj_key_AdcreativeGetDataList_ProductType = []byte("product_type")

var ffj_key_AdcreativeGetDataList_ProductRefsID = []byte("product_refs_id")

var ffj_key_AdcreativeGetDataList_CreatedTime = []byte("created_time")

var ffj_key_AdcreativeGetDataList_LastModifiedTime = []byte("last_modified_time")

func (uj *AdcreativeGetDataList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *AdcreativeGetDataList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_AdcreativeGetDataListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_AdcreativeGetDataListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_AdcreativeGetDataList_AdcreativeID, kn) {
						currentKey = ffj_t_AdcreativeGetDataList_AdcreativeID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdcreativeGetDataList_AdcreativeName, kn) {
						currentKey = ffj_t_AdcreativeGetDataList_AdcreativeName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdcreativeGetDataList_AdcreativeTemplateID, kn) {
						currentKey = ffj_t_AdcreativeGetDataList_AdcreativeTemplateID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdcreativeGetDataList_AdcreativeElements, kn) {
						currentKey = ffj_t_AdcreativeGetDataList_AdcreativeElements
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_AdcreativeGetDataList_CampaignID, kn) {
						currentKey = ffj_t_AdcreativeGetDataList_CampaignID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdcreativeGetDataList_CreatedTime, kn) {
						currentKey = ffj_t_AdcreativeGetDataList_CreatedTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_AdcreativeGetDataList_DestinationUrl, kn) {
						currentKey = ffj_t_AdcreativeGetDataList_DestinationUrl
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_AdcreativeGetDataList_LastModifiedTime, kn) {
						currentKey = ffj_t_AdcreativeGetDataList_LastModifiedTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_AdcreativeGetDataList_ProductType, kn) {
						currentKey = ffj_t_AdcreativeGetDataList_ProductType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdcreativeGetDataList_ProductRefsID, kn) {
						currentKey = ffj_t_AdcreativeGetDataList_ProductRefsID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_AdcreativeGetDataList_SiteSet, kn) {
						currentKey = ffj_t_AdcreativeGetDataList_SiteSet
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_AdcreativeGetDataList_LastModifiedTime, kn) {
					currentKey = ffj_t_AdcreativeGetDataList_LastModifiedTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdcreativeGetDataList_CreatedTime, kn) {
					currentKey = ffj_t_AdcreativeGetDataList_CreatedTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdcreativeGetDataList_ProductRefsID, kn) {
					currentKey = ffj_t_AdcreativeGetDataList_ProductRefsID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdcreativeGetDataList_ProductType, kn) {
					currentKey = ffj_t_AdcreativeGetDataList_ProductType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdcreativeGetDataList_SiteSet, kn) {
					currentKey = ffj_t_AdcreativeGetDataList_SiteSet
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdcreativeGetDataList_DestinationUrl, kn) {
					currentKey = ffj_t_AdcreativeGetDataList_DestinationUrl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdcreativeGetDataList_AdcreativeElements, kn) {
					currentKey = ffj_t_AdcreativeGetDataList_AdcreativeElements
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdcreativeGetDataList_AdcreativeTemplateID, kn) {
					currentKey = ffj_t_AdcreativeGetDataList_AdcreativeTemplateID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdcreativeGetDataList_AdcreativeName, kn) {
					currentKey = ffj_t_AdcreativeGetDataList_AdcreativeName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdcreativeGetDataList_AdcreativeID, kn) {
					currentKey = ffj_t_AdcreativeGetDataList_AdcreativeID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdcreativeGetDataList_CampaignID, kn) {
					currentKey = ffj_t_AdcreativeGetDataList_CampaignID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_AdcreativeGetDataListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_AdcreativeGetDataList_CampaignID:
					goto handle_CampaignID

				case ffj_t_AdcreativeGetDataList_AdcreativeID:
					goto handle_AdcreativeID

				case ffj_t_AdcreativeGetDataList_AdcreativeName:
					goto handle_AdcreativeName

				case ffj_t_AdcreativeGetDataList_AdcreativeTemplateID:
					goto handle_AdcreativeTemplateID

				case ffj_t_AdcreativeGetDataList_AdcreativeElements:
					goto handle_AdcreativeElements

				case ffj_t_AdcreativeGetDataList_DestinationUrl:
					goto handle_DestinationUrl

				case ffj_t_AdcreativeGetDataList_SiteSet:
					goto handle_SiteSet

				case ffj_t_AdcreativeGetDataList_ProductType:
					goto handle_ProductType

				case ffj_t_AdcreativeGetDataList_ProductRefsID:
					goto handle_ProductRefsID

				case ffj_t_AdcreativeGetDataList_CreatedTime:
					goto handle_CreatedTime

				case ffj_t_AdcreativeGetDataList_LastModifiedTime:
					goto handle_LastModifiedTime

				case ffj_t_AdcreativeGetDataListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_CampaignID:

	/* handler: uj.CampaignID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.CampaignID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AdcreativeID:

	/* handler: uj.AdcreativeID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.AdcreativeID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AdcreativeName:

	/* handler: uj.AdcreativeName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AdcreativeName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AdcreativeTemplateID:

	/* handler: uj.AdcreativeTemplateID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.AdcreativeTemplateID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AdcreativeElements:

	/* handler: uj.AdcreativeElements type=gdt.AdcreativeElementsType kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.AdcreativeElements.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DestinationUrl:

	/* handler: uj.DestinationUrl type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.DestinationUrl = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SiteSet:

	/* handler: uj.SiteSet type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.SiteSet = nil
		} else {

			uj.SiteSet = []string{}

			wantVal := true

			for {

				var tmp_uj__SiteSet string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__SiteSet type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__SiteSet = string(string(outBuf))

					}
				}

				uj.SiteSet = append(uj.SiteSet, tmp_uj__SiteSet)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProductType:

	/* handler: uj.ProductType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ProductType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProductRefsID:

	/* handler: uj.ProductRefsID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ProductRefsID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CreatedTime:

	/* handler: uj.CreatedTime type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.CreatedTime = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastModifiedTime:

	/* handler: uj.LastModifiedTime type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.LastModifiedTime = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *AdcreativeGetResponse) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *AdcreativeGetResponse) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"code":`)
	fflib.FormatBits2(buf, uint64(mj.Code), 10, mj.Code < 0)
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(mj.Message))
	buf.WriteString(`,"data":`)

	{

		err = mj.Data.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_AdcreativeGetResponsebase = iota
	ffj_t_AdcreativeGetResponseno_such_key

	ffj_t_AdcreativeGetResponse_Code

	ffj_t_AdcreativeGetResponse_Message

	ffj_t_AdcreativeGetResponse_Data
)

var ffj_key_AdcreativeGetResponse_Code = []byte("code")

var ffj_key_AdcreativeGetResponse_Message = []byte("message")

var ffj_key_AdcreativeGetResponse_Data = []byte("data")

func (uj *AdcreativeGetResponse) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *AdcreativeGetResponse) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_AdcreativeGetResponsebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_AdcreativeGetResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_AdcreativeGetResponse_Code, kn) {
						currentKey = ffj_t_AdcreativeGetResponse_Code
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_AdcreativeGetResponse_Data, kn) {
						currentKey = ffj_t_AdcreativeGetResponse_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_AdcreativeGetResponse_Message, kn) {
						currentKey = ffj_t_AdcreativeGetResponse_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_AdcreativeGetResponse_Data, kn) {
					currentKey = ffj_t_AdcreativeGetResponse_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdcreativeGetResponse_Message, kn) {
					currentKey = ffj_t_AdcreativeGetResponse_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AdcreativeGetResponse_Code, kn) {
					currentKey = ffj_t_AdcreativeGetResponse_Code
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_AdcreativeGetResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_AdcreativeGetResponse_Code:
					goto handle_Code

				case ffj_t_AdcreativeGetResponse_Message:
					goto handle_Message

				case ffj_t_AdcreativeGetResponse_Data:
					goto handle_Data

				case ffj_t_AdcreativeGetResponseno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Code:

	/* handler: uj.Code type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Code = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=gdt.AdcreativeGetData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Data.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *AdgroupsGetData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *AdgroupsGetData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"list":`)
	if mj.List != nil {
		buf.WriteString(`[`)
		for i, v := range mj.List {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"page_info":`)

	{

		err = mj.PageInfo.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_AdgroupsGetDatabase = iota
	ffj_t_AdgroupsGetDatano_such_key

	ffj_t_AdgroupsGetData_List

	ffj_t_AdgroupsGetData_PageInfo
)

var ffj_key_AdgroupsGetData_List = []byte("list")

var ffj_key_AdgroupsGetData_PageInfo = []byte("page_info")

func (uj *AdgroupsGetData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *AdgroupsGetData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_AdgroupsGetDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_AdgroupsGetDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_AdgroupsGetData_List, kn) {
						currentKey = ffj_t_AdgroupsGetData_List
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_AdgroupsGetData_PageInfo, kn) {
						currentKey = ffj_t_AdgroupsGetData_PageInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_AdgroupsGetData_PageInfo, kn) {
					currentKey = ffj_t_AdgroupsGetData_PageInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdgroupsGetData_List, kn) {
					currentKey = ffj_t_AdgroupsGetData_List
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_AdgroupsGetDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_AdgroupsGetData_List:
					goto handle_List

				case ffj_t_AdgroupsGetData_PageInfo:
					goto handle_PageInfo

				case ffj_t_AdgroupsGetDatano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_List:

	/* handler: uj.List type=[]gdt.AdgroupsGetDataList kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.List = nil
		} else {

			uj.List = []AdgroupsGetDataList{}

			wantVal := true

			for {

				var tmp_uj__List AdgroupsGetDataList

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__List type=gdt.AdgroupsGetDataList kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__List.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.List = append(uj.List, tmp_uj__List)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PageInfo:

	/* handler: uj.PageInfo type=gdt.PageInfoData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.PageInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *AdgroupsGetDataList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *AdgroupsGetDataList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"campaign_id":`)
	fflib.FormatBits2(buf, uint64(mj.CampaignID), 10, mj.CampaignID < 0)
	buf.WriteString(`,"adgroup_id":`)
	fflib.FormatBits2(buf, uint64(mj.AdgroupID), 10, mj.AdgroupID < 0)
	buf.WriteString(`,"adgroup_name":`)
	fflib.WriteJsonString(buf, string(mj.AdgroupName))
	buf.WriteString(`,"site_set":`)
	if mj.SiteSet != nil {
		buf.WriteString(`[`)
		for i, v := range mj.SiteSet {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"optimization_goal":`)
	fflib.WriteJsonString(buf, string(mj.OptimizationGoal))
	buf.WriteString(`,"billing_event":`)
	fflib.WriteJsonString(buf, string(mj.BillingEvent))
	buf.WriteString(`,"bid_amount":`)
	fflib.FormatBits2(buf, uint64(mj.BidAmount), 10, mj.BidAmount < 0)
	buf.WriteString(`,"daily_budget":`)
	fflib.FormatBits2(buf, uint64(mj.DailyBudget), 10, mj.DailyBudget < 0)
	buf.WriteString(`,"product_type":`)
	fflib.WriteJsonString(buf, string(mj.ProductType))
	buf.WriteString(`,"product_refs_id":`)
	fflib.WriteJsonString(buf, string(mj.ProductRefsID))
	buf.WriteString(`,"subordinate_product_refs_id":`)
	fflib.WriteJsonString(buf, string(mj.SubordinateProductRefsID))
	buf.WriteString(`,"targeting_id":`)
	fflib.FormatBits2(buf, uint64(mj.TargetingID), 10, mj.TargetingID < 0)
	buf.WriteString(`,"targeting":`)

	{

		err = mj.Targeting.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"begin_date":`)
	fflib.WriteJsonString(buf, string(mj.BeginDate))
	buf.WriteString(`,"end_date":`)
	fflib.WriteJsonString(buf, string(mj.EndDate))
	buf.WriteString(`,"time_series":`)
	fflib.WriteJsonString(buf, string(mj.TimeSeries))
	buf.WriteString(`,"configured_status":`)
	fflib.WriteJsonString(buf, string(mj.ConfiguredStatus))
	buf.WriteString(`,"system_status":`)
	fflib.WriteJsonString(buf, string(mj.SystemStatus))
	buf.WriteString(`,"reject_message":`)
	fflib.WriteJsonString(buf, string(mj.RejectMessage))
	buf.WriteString(`,"customized_category":`)
	fflib.WriteJsonString(buf, string(mj.CustomizedCategory))
	buf.WriteString(`,"created_time":`)
	fflib.FormatBits2(buf, uint64(mj.CreatedTime), 10, mj.CreatedTime < 0)
	buf.WriteString(`,"last_modified_time":`)
	fflib.FormatBits2(buf, uint64(mj.LastModifiedTime), 10, mj.LastModifiedTime < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_AdgroupsGetDataListbase = iota
	ffj_t_AdgroupsGetDataListno_such_key

	ffj_t_AdgroupsGetDataList_CampaignID

	ffj_t_AdgroupsGetDataList_AdgroupID

	ffj_t_AdgroupsGetDataList_AdgroupName

	ffj_t_AdgroupsGetDataList_SiteSet

	ffj_t_AdgroupsGetDataList_OptimizationGoal

	ffj_t_AdgroupsGetDataList_BillingEvent

	ffj_t_AdgroupsGetDataList_BidAmount

	ffj_t_AdgroupsGetDataList_DailyBudget

	ffj_t_AdgroupsGetDataList_ProductType

	ffj_t_AdgroupsGetDataList_ProductRefsID

	ffj_t_AdgroupsGetDataList_SubordinateProductRefsID

	ffj_t_AdgroupsGetDataList_TargetingID

	ffj_t_AdgroupsGetDataList_Targeting

	ffj_t_AdgroupsGetDataList_BeginDate

	ffj_t_AdgroupsGetDataList_EndDate

	ffj_t_AdgroupsGetDataList_TimeSeries

	ffj_t_AdgroupsGetDataList_ConfiguredStatus

	ffj_t_AdgroupsGetDataList_SystemStatus

	ffj_t_AdgroupsGetDataList_RejectMessage

	ffj_t_AdgroupsGetDataList_CustomizedCategory

	ffj_t_AdgroupsGetDataList_CreatedTime

	ffj_t_AdgroupsGetDataList_LastModifiedTime
)

var ffj_key_AdgroupsGetDataList_CampaignID = []byte("campaign_id")

var ffj_key_AdgroupsGetDataList_AdgroupID = []byte("adgroup_id")

var ffj_key_AdgroupsGetDataList_AdgroupName = []byte("adgroup_name")

var ffj_key_AdgroupsGetDataList_SiteSet = []byte("site_set")

var ffj_key_AdgroupsGetDataList_OptimizationGoal = []byte("optimization_goal")

var ffj_key_AdgroupsGetDataList_BillingEvent = []byte("billing_event")

var ffj_key_AdgroupsGetDataList_BidAmount = []byte("bid_amount")

var ffj_key_AdgroupsGetDataList_DailyBudget = []byte("daily_budget")

var ffj_key_AdgroupsGetDataList_ProductType = []byte("product_type")

var ffj_key_AdgroupsGetDataList_ProductRefsID = []byte("product_refs_id")

var ffj_key_AdgroupsGetDataList_SubordinateProductRefsID = []byte("subordinate_product_refs_id")

var ffj_key_AdgroupsGetDataList_TargetingID = []byte("targeting_id")

var ffj_key_AdgroupsGetDataList_Targeting = []byte("targeting")

var ffj_key_AdgroupsGetDataList_BeginDate = []byte("begin_date")

var ffj_key_AdgroupsGetDataList_EndDate = []byte("end_date")

var ffj_key_AdgroupsGetDataList_TimeSeries = []byte("time_series")

var ffj_key_AdgroupsGetDataList_ConfiguredStatus = []byte("configured_status")

var ffj_key_AdgroupsGetDataList_SystemStatus = []byte("system_status")

var ffj_key_AdgroupsGetDataList_RejectMessage = []byte("reject_message")

var ffj_key_AdgroupsGetDataList_CustomizedCategory = []byte("customized_category")

var ffj_key_AdgroupsGetDataList_CreatedTime = []byte("created_time")

var ffj_key_AdgroupsGetDataList_LastModifiedTime = []byte("last_modified_time")

func (uj *AdgroupsGetDataList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *AdgroupsGetDataList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_AdgroupsGetDataListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_AdgroupsGetDataListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_AdgroupsGetDataList_AdgroupID, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_AdgroupID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdgroupsGetDataList_AdgroupName, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_AdgroupName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffj_key_AdgroupsGetDataList_BillingEvent, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_BillingEvent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdgroupsGetDataList_BidAmount, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_BidAmount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdgroupsGetDataList_BeginDate, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_BeginDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_AdgroupsGetDataList_CampaignID, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_CampaignID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdgroupsGetDataList_ConfiguredStatus, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_ConfiguredStatus
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdgroupsGetDataList_CustomizedCategory, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_CustomizedCategory
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdgroupsGetDataList_CreatedTime, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_CreatedTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_AdgroupsGetDataList_DailyBudget, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_DailyBudget
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_AdgroupsGetDataList_EndDate, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_EndDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_AdgroupsGetDataList_LastModifiedTime, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_LastModifiedTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_AdgroupsGetDataList_OptimizationGoal, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_OptimizationGoal
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_AdgroupsGetDataList_ProductType, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_ProductType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdgroupsGetDataList_ProductRefsID, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_ProductRefsID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_AdgroupsGetDataList_RejectMessage, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_RejectMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_AdgroupsGetDataList_SiteSet, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_SiteSet
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdgroupsGetDataList_SubordinateProductRefsID, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_SubordinateProductRefsID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdgroupsGetDataList_SystemStatus, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_SystemStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_AdgroupsGetDataList_TargetingID, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_TargetingID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdgroupsGetDataList_Targeting, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_Targeting
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdgroupsGetDataList_TimeSeries, kn) {
						currentKey = ffj_t_AdgroupsGetDataList_TimeSeries
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_AdgroupsGetDataList_LastModifiedTime, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_LastModifiedTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdgroupsGetDataList_CreatedTime, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_CreatedTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdgroupsGetDataList_CustomizedCategory, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_CustomizedCategory
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdgroupsGetDataList_RejectMessage, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_RejectMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdgroupsGetDataList_SystemStatus, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_SystemStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdgroupsGetDataList_ConfiguredStatus, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_ConfiguredStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdgroupsGetDataList_TimeSeries, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_TimeSeries
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdgroupsGetDataList_EndDate, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_EndDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdgroupsGetDataList_BeginDate, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_BeginDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AdgroupsGetDataList_Targeting, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_Targeting
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdgroupsGetDataList_TargetingID, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_TargetingID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdgroupsGetDataList_SubordinateProductRefsID, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_SubordinateProductRefsID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdgroupsGetDataList_ProductRefsID, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_ProductRefsID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdgroupsGetDataList_ProductType, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_ProductType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdgroupsGetDataList_DailyBudget, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_DailyBudget
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdgroupsGetDataList_BidAmount, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_BidAmount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdgroupsGetDataList_BillingEvent, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_BillingEvent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdgroupsGetDataList_OptimizationGoal, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_OptimizationGoal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdgroupsGetDataList_SiteSet, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_SiteSet
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdgroupsGetDataList_AdgroupName, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_AdgroupName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdgroupsGetDataList_AdgroupID, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_AdgroupID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdgroupsGetDataList_CampaignID, kn) {
					currentKey = ffj_t_AdgroupsGetDataList_CampaignID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_AdgroupsGetDataListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_AdgroupsGetDataList_CampaignID:
					goto handle_CampaignID

				case ffj_t_AdgroupsGetDataList_AdgroupID:
					goto handle_AdgroupID

				case ffj_t_AdgroupsGetDataList_AdgroupName:
					goto handle_AdgroupName

				case ffj_t_AdgroupsGetDataList_SiteSet:
					goto handle_SiteSet

				case ffj_t_AdgroupsGetDataList_OptimizationGoal:
					goto handle_OptimizationGoal

				case ffj_t_AdgroupsGetDataList_BillingEvent:
					goto handle_BillingEvent

				case ffj_t_AdgroupsGetDataList_BidAmount:
					goto handle_BidAmount

				case ffj_t_AdgroupsGetDataList_DailyBudget:
					goto handle_DailyBudget

				case ffj_t_AdgroupsGetDataList_ProductType:
					goto handle_ProductType

				case ffj_t_AdgroupsGetDataList_ProductRefsID:
					goto handle_ProductRefsID

				case ffj_t_AdgroupsGetDataList_SubordinateProductRefsID:
					goto handle_SubordinateProductRefsID

				case ffj_t_AdgroupsGetDataList_TargetingID:
					goto handle_TargetingID

				case ffj_t_AdgroupsGetDataList_Targeting:
					goto handle_Targeting

				case ffj_t_AdgroupsGetDataList_BeginDate:
					goto handle_BeginDate

				case ffj_t_AdgroupsGetDataList_EndDate:
					goto handle_EndDate

				case ffj_t_AdgroupsGetDataList_TimeSeries:
					goto handle_TimeSeries

				case ffj_t_AdgroupsGetDataList_ConfiguredStatus:
					goto handle_ConfiguredStatus

				case ffj_t_AdgroupsGetDataList_SystemStatus:
					goto handle_SystemStatus

				case ffj_t_AdgroupsGetDataList_RejectMessage:
					goto handle_RejectMessage

				case ffj_t_AdgroupsGetDataList_CustomizedCategory:
					goto handle_CustomizedCategory

				case ffj_t_AdgroupsGetDataList_CreatedTime:
					goto handle_CreatedTime

				case ffj_t_AdgroupsGetDataList_LastModifiedTime:
					goto handle_LastModifiedTime

				case ffj_t_AdgroupsGetDataListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_CampaignID:

	/* handler: uj.CampaignID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.CampaignID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AdgroupID:

	/* handler: uj.AdgroupID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.AdgroupID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AdgroupName:

	/* handler: uj.AdgroupName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AdgroupName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SiteSet:

	/* handler: uj.SiteSet type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.SiteSet = nil
		} else {

			uj.SiteSet = []string{}

			wantVal := true

			for {

				var tmp_uj__SiteSet string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__SiteSet type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__SiteSet = string(string(outBuf))

					}
				}

				uj.SiteSet = append(uj.SiteSet, tmp_uj__SiteSet)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OptimizationGoal:

	/* handler: uj.OptimizationGoal type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.OptimizationGoal = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BillingEvent:

	/* handler: uj.BillingEvent type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.BillingEvent = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BidAmount:

	/* handler: uj.BidAmount type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.BidAmount = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DailyBudget:

	/* handler: uj.DailyBudget type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.DailyBudget = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProductType:

	/* handler: uj.ProductType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ProductType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProductRefsID:

	/* handler: uj.ProductRefsID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ProductRefsID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SubordinateProductRefsID:

	/* handler: uj.SubordinateProductRefsID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.SubordinateProductRefsID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TargetingID:

	/* handler: uj.TargetingID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.TargetingID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Targeting:

	/* handler: uj.Targeting type=gdt.TargetingType kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Targeting.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BeginDate:

	/* handler: uj.BeginDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.BeginDate = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EndDate:

	/* handler: uj.EndDate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.EndDate = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TimeSeries:

	/* handler: uj.TimeSeries type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.TimeSeries = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ConfiguredStatus:

	/* handler: uj.ConfiguredStatus type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ConfiguredStatus = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SystemStatus:

	/* handler: uj.SystemStatus type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.SystemStatus = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RejectMessage:

	/* handler: uj.RejectMessage type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.RejectMessage = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CustomizedCategory:

	/* handler: uj.CustomizedCategory type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.CustomizedCategory = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CreatedTime:

	/* handler: uj.CreatedTime type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.CreatedTime = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastModifiedTime:

	/* handler: uj.LastModifiedTime type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.LastModifiedTime = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *AdgroupsGetResponse) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *AdgroupsGetResponse) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"code":`)
	fflib.FormatBits2(buf, uint64(mj.Code), 10, mj.Code < 0)
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(mj.Message))
	buf.WriteString(`,"data":`)

	{

		err = mj.Data.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_AdgroupsGetResponsebase = iota
	ffj_t_AdgroupsGetResponseno_such_key

	ffj_t_AdgroupsGetResponse_Code

	ffj_t_AdgroupsGetResponse_Message

	ffj_t_AdgroupsGetResponse_Data
)

var ffj_key_AdgroupsGetResponse_Code = []byte("code")

var ffj_key_AdgroupsGetResponse_Message = []byte("message")

var ffj_key_AdgroupsGetResponse_Data = []byte("data")

func (uj *AdgroupsGetResponse) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *AdgroupsGetResponse) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_AdgroupsGetResponsebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_AdgroupsGetResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_AdgroupsGetResponse_Code, kn) {
						currentKey = ffj_t_AdgroupsGetResponse_Code
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_AdgroupsGetResponse_Data, kn) {
						currentKey = ffj_t_AdgroupsGetResponse_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_AdgroupsGetResponse_Message, kn) {
						currentKey = ffj_t_AdgroupsGetResponse_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_AdgroupsGetResponse_Data, kn) {
					currentKey = ffj_t_AdgroupsGetResponse_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdgroupsGetResponse_Message, kn) {
					currentKey = ffj_t_AdgroupsGetResponse_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AdgroupsGetResponse_Code, kn) {
					currentKey = ffj_t_AdgroupsGetResponse_Code
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_AdgroupsGetResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_AdgroupsGetResponse_Code:
					goto handle_Code

				case ffj_t_AdgroupsGetResponse_Message:
					goto handle_Message

				case ffj_t_AdgroupsGetResponse_Data:
					goto handle_Data

				case ffj_t_AdgroupsGetResponseno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Code:

	/* handler: uj.Code type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Code = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=gdt.AdgroupsGetData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Data.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *AdsGetData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *AdsGetData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"list":`)
	if mj.List != nil {
		buf.WriteString(`[`)
		for i, v := range mj.List {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"page_info":`)

	{

		err = mj.PageInfo.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_AdsGetDatabase = iota
	ffj_t_AdsGetDatano_such_key

	ffj_t_AdsGetData_List

	ffj_t_AdsGetData_PageInfo
)

var ffj_key_AdsGetData_List = []byte("list")

var ffj_key_AdsGetData_PageInfo = []byte("page_info")

func (uj *AdsGetData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *AdsGetData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_AdsGetDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_AdsGetDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_AdsGetData_List, kn) {
						currentKey = ffj_t_AdsGetData_List
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_AdsGetData_PageInfo, kn) {
						currentKey = ffj_t_AdsGetData_PageInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_AdsGetData_PageInfo, kn) {
					currentKey = ffj_t_AdsGetData_PageInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdsGetData_List, kn) {
					currentKey = ffj_t_AdsGetData_List
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_AdsGetDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_AdsGetData_List:
					goto handle_List

				case ffj_t_AdsGetData_PageInfo:
					goto handle_PageInfo

				case ffj_t_AdsGetDatano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_List:

	/* handler: uj.List type=[]gdt.AdsGetDataList kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.List = nil
		} else {

			uj.List = []AdsGetDataList{}

			wantVal := true

			for {

				var tmp_uj__List AdsGetDataList

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__List type=gdt.AdsGetDataList kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__List.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.List = append(uj.List, tmp_uj__List)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PageInfo:

	/* handler: uj.PageInfo type=gdt.PageInfoData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.PageInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *AdsGetDataList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *AdsGetDataList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"campaign_id":`)
	fflib.FormatBits2(buf, uint64(mj.CampaignID), 10, mj.CampaignID < 0)
	buf.WriteString(`,"adgroup_id":`)
	fflib.FormatBits2(buf, uint64(mj.AdgroupID), 10, mj.AdgroupID < 0)
	buf.WriteString(`,"ad_id":`)
	fflib.FormatBits2(buf, uint64(mj.AdID), 10, mj.AdID < 0)
	buf.WriteString(`,"ad_name":`)
	fflib.WriteJsonString(buf, string(mj.AdName))
	buf.WriteString(`,"adcreative":`)

	{

		err = mj.Adcreative.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"configured_status":`)
	fflib.WriteJsonString(buf, string(mj.ConfiguredStatus))
	buf.WriteString(`,"system_status":`)
	fflib.WriteJsonString(buf, string(mj.SystemStatus))
	buf.WriteString(`,"impression_tracking_url":`)
	fflib.WriteJsonString(buf, string(mj.ImpressionTrackingUrl))
	buf.WriteString(`,"click_tracking_url":`)
	fflib.WriteJsonString(buf, string(mj.ClickTrackingUrl))
	buf.WriteString(`,"reject_message":`)
	fflib.WriteJsonString(buf, string(mj.RejectMessage))
	buf.WriteString(`,"created_time":`)
	fflib.FormatBits2(buf, uint64(mj.CreatedTime), 10, mj.CreatedTime < 0)
	buf.WriteString(`,"last_modified_time":`)
	fflib.FormatBits2(buf, uint64(mj.LastModifiedTime), 10, mj.LastModifiedTime < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_AdsGetDataListbase = iota
	ffj_t_AdsGetDataListno_such_key

	ffj_t_AdsGetDataList_CampaignID

	ffj_t_AdsGetDataList_AdgroupID

	ffj_t_AdsGetDataList_AdID

	ffj_t_AdsGetDataList_AdName

	ffj_t_AdsGetDataList_Adcreative

	ffj_t_AdsGetDataList_ConfiguredStatus

	ffj_t_AdsGetDataList_SystemStatus

	ffj_t_AdsGetDataList_ImpressionTrackingUrl

	ffj_t_AdsGetDataList_ClickTrackingUrl

	ffj_t_AdsGetDataList_RejectMessage

	ffj_t_AdsGetDataList_CreatedTime

	ffj_t_AdsGetDataList_LastModifiedTime
)

var ffj_key_AdsGetDataList_CampaignID = []byte("campaign_id")

var ffj_key_AdsGetDataList_AdgroupID = []byte("adgroup_id")

var ffj_key_AdsGetDataList_AdID = []byte("ad_id")

var ffj_key_AdsGetDataList_AdName = []byte("ad_name")

var ffj_key_AdsGetDataList_Adcreative = []byte("adcreative")

var ffj_key_AdsGetDataList_ConfiguredStatus = []byte("configured_status")

var ffj_key_AdsGetDataList_SystemStatus = []byte("system_status")

var ffj_key_AdsGetDataList_ImpressionTrackingUrl = []byte("impression_tracking_url")

var ffj_key_AdsGetDataList_ClickTrackingUrl = []byte("click_tracking_url")

var ffj_key_AdsGetDataList_RejectMessage = []byte("reject_message")

var ffj_key_AdsGetDataList_CreatedTime = []byte("created_time")

var ffj_key_AdsGetDataList_LastModifiedTime = []byte("last_modified_time")

func (uj *AdsGetDataList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *AdsGetDataList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_AdsGetDataListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_AdsGetDataListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_AdsGetDataList_AdgroupID, kn) {
						currentKey = ffj_t_AdsGetDataList_AdgroupID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdsGetDataList_AdID, kn) {
						currentKey = ffj_t_AdsGetDataList_AdID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdsGetDataList_AdName, kn) {
						currentKey = ffj_t_AdsGetDataList_AdName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdsGetDataList_Adcreative, kn) {
						currentKey = ffj_t_AdsGetDataList_Adcreative
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_AdsGetDataList_CampaignID, kn) {
						currentKey = ffj_t_AdsGetDataList_CampaignID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdsGetDataList_ConfiguredStatus, kn) {
						currentKey = ffj_t_AdsGetDataList_ConfiguredStatus
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdsGetDataList_ClickTrackingUrl, kn) {
						currentKey = ffj_t_AdsGetDataList_ClickTrackingUrl
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AdsGetDataList_CreatedTime, kn) {
						currentKey = ffj_t_AdsGetDataList_CreatedTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_AdsGetDataList_ImpressionTrackingUrl, kn) {
						currentKey = ffj_t_AdsGetDataList_ImpressionTrackingUrl
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_AdsGetDataList_LastModifiedTime, kn) {
						currentKey = ffj_t_AdsGetDataList_LastModifiedTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_AdsGetDataList_RejectMessage, kn) {
						currentKey = ffj_t_AdsGetDataList_RejectMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_AdsGetDataList_SystemStatus, kn) {
						currentKey = ffj_t_AdsGetDataList_SystemStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_AdsGetDataList_LastModifiedTime, kn) {
					currentKey = ffj_t_AdsGetDataList_LastModifiedTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdsGetDataList_CreatedTime, kn) {
					currentKey = ffj_t_AdsGetDataList_CreatedTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdsGetDataList_RejectMessage, kn) {
					currentKey = ffj_t_AdsGetDataList_RejectMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdsGetDataList_ClickTrackingUrl, kn) {
					currentKey = ffj_t_AdsGetDataList_ClickTrackingUrl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdsGetDataList_ImpressionTrackingUrl, kn) {
					currentKey = ffj_t_AdsGetDataList_ImpressionTrackingUrl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdsGetDataList_SystemStatus, kn) {
					currentKey = ffj_t_AdsGetDataList_SystemStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdsGetDataList_ConfiguredStatus, kn) {
					currentKey = ffj_t_AdsGetDataList_ConfiguredStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AdsGetDataList_Adcreative, kn) {
					currentKey = ffj_t_AdsGetDataList_Adcreative
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdsGetDataList_AdName, kn) {
					currentKey = ffj_t_AdsGetDataList_AdName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdsGetDataList_AdID, kn) {
					currentKey = ffj_t_AdsGetDataList_AdID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdsGetDataList_AdgroupID, kn) {
					currentKey = ffj_t_AdsGetDataList_AdgroupID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_AdsGetDataList_CampaignID, kn) {
					currentKey = ffj_t_AdsGetDataList_CampaignID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_AdsGetDataListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_AdsGetDataList_CampaignID:
					goto handle_CampaignID

				case ffj_t_AdsGetDataList_AdgroupID:
					goto handle_AdgroupID

				case ffj_t_AdsGetDataList_AdID:
					goto handle_AdID

				case ffj_t_AdsGetDataList_AdName:
					goto handle_AdName

				case ffj_t_AdsGetDataList_Adcreative:
					goto handle_Adcreative

				case ffj_t_AdsGetDataList_ConfiguredStatus:
					goto handle_ConfiguredStatus

				case ffj_t_AdsGetDataList_SystemStatus:
					goto handle_SystemStatus

				case ffj_t_AdsGetDataList_ImpressionTrackingUrl:
					goto handle_ImpressionTrackingUrl

				case ffj_t_AdsGetDataList_ClickTrackingUrl:
					goto handle_ClickTrackingUrl

				case ffj_t_AdsGetDataList_RejectMessage:
					goto handle_RejectMessage

				case ffj_t_AdsGetDataList_CreatedTime:
					goto handle_CreatedTime

				case ffj_t_AdsGetDataList_LastModifiedTime:
					goto handle_LastModifiedTime

				case ffj_t_AdsGetDataListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_CampaignID:

	/* handler: uj.CampaignID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.CampaignID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AdgroupID:

	/* handler: uj.AdgroupID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.AdgroupID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AdID:

	/* handler: uj.AdID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.AdID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AdName:

	/* handler: uj.AdName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AdName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Adcreative:

	/* handler: uj.Adcreative type=gdt.AdcreativeGetDataList kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Adcreative.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ConfiguredStatus:

	/* handler: uj.ConfiguredStatus type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ConfiguredStatus = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SystemStatus:

	/* handler: uj.SystemStatus type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.SystemStatus = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImpressionTrackingUrl:

	/* handler: uj.ImpressionTrackingUrl type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ImpressionTrackingUrl = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ClickTrackingUrl:

	/* handler: uj.ClickTrackingUrl type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ClickTrackingUrl = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RejectMessage:

	/* handler: uj.RejectMessage type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.RejectMessage = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CreatedTime:

	/* handler: uj.CreatedTime type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.CreatedTime = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastModifiedTime:

	/* handler: uj.LastModifiedTime type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.LastModifiedTime = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *AdsGetResponse) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *AdsGetResponse) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"code":`)
	fflib.FormatBits2(buf, uint64(mj.Code), 10, mj.Code < 0)
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(mj.Message))
	buf.WriteString(`,"data":`)

	{

		err = mj.Data.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_AdsGetResponsebase = iota
	ffj_t_AdsGetResponseno_such_key

	ffj_t_AdsGetResponse_Code

	ffj_t_AdsGetResponse_Message

	ffj_t_AdsGetResponse_Data
)

var ffj_key_AdsGetResponse_Code = []byte("code")

var ffj_key_AdsGetResponse_Message = []byte("message")

var ffj_key_AdsGetResponse_Data = []byte("data")

func (uj *AdsGetResponse) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *AdsGetResponse) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_AdsGetResponsebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_AdsGetResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_AdsGetResponse_Code, kn) {
						currentKey = ffj_t_AdsGetResponse_Code
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_AdsGetResponse_Data, kn) {
						currentKey = ffj_t_AdsGetResponse_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_AdsGetResponse_Message, kn) {
						currentKey = ffj_t_AdsGetResponse_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_AdsGetResponse_Data, kn) {
					currentKey = ffj_t_AdsGetResponse_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AdsGetResponse_Message, kn) {
					currentKey = ffj_t_AdsGetResponse_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AdsGetResponse_Code, kn) {
					currentKey = ffj_t_AdsGetResponse_Code
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_AdsGetResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_AdsGetResponse_Code:
					goto handle_Code

				case ffj_t_AdsGetResponse_Message:
					goto handle_Message

				case ffj_t_AdsGetResponse_Data:
					goto handle_Data

				case ffj_t_AdsGetResponseno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Code:

	/* handler: uj.Code type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Code = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=gdt.AdsGetData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Data.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *CampaignsGetData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *CampaignsGetData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"list":`)
	if mj.List != nil {
		buf.WriteString(`[`)
		for i, v := range mj.List {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"page_info":`)

	{

		err = mj.PageInfo.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_CampaignsGetDatabase = iota
	ffj_t_CampaignsGetDatano_such_key

	ffj_t_CampaignsGetData_List

	ffj_t_CampaignsGetData_PageInfo
)

var ffj_key_CampaignsGetData_List = []byte("list")

var ffj_key_CampaignsGetData_PageInfo = []byte("page_info")

func (uj *CampaignsGetData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *CampaignsGetData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_CampaignsGetDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_CampaignsGetDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_CampaignsGetData_List, kn) {
						currentKey = ffj_t_CampaignsGetData_List
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_CampaignsGetData_PageInfo, kn) {
						currentKey = ffj_t_CampaignsGetData_PageInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_CampaignsGetData_PageInfo, kn) {
					currentKey = ffj_t_CampaignsGetData_PageInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CampaignsGetData_List, kn) {
					currentKey = ffj_t_CampaignsGetData_List
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_CampaignsGetDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_CampaignsGetData_List:
					goto handle_List

				case ffj_t_CampaignsGetData_PageInfo:
					goto handle_PageInfo

				case ffj_t_CampaignsGetDatano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_List:

	/* handler: uj.List type=[]gdt.CampaignsGetDataList kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.List = nil
		} else {

			uj.List = []CampaignsGetDataList{}

			wantVal := true

			for {

				var tmp_uj__List CampaignsGetDataList

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__List type=gdt.CampaignsGetDataList kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__List.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.List = append(uj.List, tmp_uj__List)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PageInfo:

	/* handler: uj.PageInfo type=gdt.PageInfoData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.PageInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *CampaignsGetDataList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *CampaignsGetDataList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"campaign_id":`)
	fflib.FormatBits2(buf, uint64(mj.CampaignID), 10, mj.CampaignID < 0)
	buf.WriteString(`,"campaign_name":`)
	fflib.WriteJsonString(buf, string(mj.CampaignName))
	buf.WriteString(`,"configured_status":`)
	fflib.WriteJsonString(buf, string(mj.ConfiguredStatus))
	buf.WriteString(`,"campaign_type":`)
	fflib.WriteJsonString(buf, string(mj.CampaignType))
	buf.WriteString(`,"product_type":`)
	fflib.WriteJsonString(buf, string(mj.ProductType))
	buf.WriteString(`,"daily_budget":`)
	fflib.FormatBits2(buf, uint64(mj.DailyBudget), 10, mj.DailyBudget < 0)
	buf.WriteString(`,"budget_reach_date":`)
	fflib.FormatBits2(buf, uint64(mj.BudgetReachDate), 10, mj.BudgetReachDate < 0)
	buf.WriteString(`,"created_time":`)
	fflib.FormatBits2(buf, uint64(mj.CreatedTime), 10, mj.CreatedTime < 0)
	buf.WriteString(`,"last_modified_time":`)
	fflib.FormatBits2(buf, uint64(mj.LastModifiedTime), 10, mj.LastModifiedTime < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_CampaignsGetDataListbase = iota
	ffj_t_CampaignsGetDataListno_such_key

	ffj_t_CampaignsGetDataList_CampaignID

	ffj_t_CampaignsGetDataList_CampaignName

	ffj_t_CampaignsGetDataList_ConfiguredStatus

	ffj_t_CampaignsGetDataList_CampaignType

	ffj_t_CampaignsGetDataList_ProductType

	ffj_t_CampaignsGetDataList_DailyBudget

	ffj_t_CampaignsGetDataList_BudgetReachDate

	ffj_t_CampaignsGetDataList_CreatedTime

	ffj_t_CampaignsGetDataList_LastModifiedTime
)

var ffj_key_CampaignsGetDataList_CampaignID = []byte("campaign_id")

var ffj_key_CampaignsGetDataList_CampaignName = []byte("campaign_name")

var ffj_key_CampaignsGetDataList_ConfiguredStatus = []byte("configured_status")

var ffj_key_CampaignsGetDataList_CampaignType = []byte("campaign_type")

var ffj_key_CampaignsGetDataList_ProductType = []byte("product_type")

var ffj_key_CampaignsGetDataList_DailyBudget = []byte("daily_budget")

var ffj_key_CampaignsGetDataList_BudgetReachDate = []byte("budget_reach_date")

var ffj_key_CampaignsGetDataList_CreatedTime = []byte("created_time")

var ffj_key_CampaignsGetDataList_LastModifiedTime = []byte("last_modified_time")

func (uj *CampaignsGetDataList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *CampaignsGetDataList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_CampaignsGetDataListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_CampaignsGetDataListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffj_key_CampaignsGetDataList_BudgetReachDate, kn) {
						currentKey = ffj_t_CampaignsGetDataList_BudgetReachDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_CampaignsGetDataList_CampaignID, kn) {
						currentKey = ffj_t_CampaignsGetDataList_CampaignID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_CampaignsGetDataList_CampaignName, kn) {
						currentKey = ffj_t_CampaignsGetDataList_CampaignName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_CampaignsGetDataList_ConfiguredStatus, kn) {
						currentKey = ffj_t_CampaignsGetDataList_ConfiguredStatus
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_CampaignsGetDataList_CampaignType, kn) {
						currentKey = ffj_t_CampaignsGetDataList_CampaignType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_CampaignsGetDataList_CreatedTime, kn) {
						currentKey = ffj_t_CampaignsGetDataList_CreatedTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_CampaignsGetDataList_DailyBudget, kn) {
						currentKey = ffj_t_CampaignsGetDataList_DailyBudget
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_CampaignsGetDataList_LastModifiedTime, kn) {
						currentKey = ffj_t_CampaignsGetDataList_LastModifiedTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_CampaignsGetDataList_ProductType, kn) {
						currentKey = ffj_t_CampaignsGetDataList_ProductType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_CampaignsGetDataList_LastModifiedTime, kn) {
					currentKey = ffj_t_CampaignsGetDataList_LastModifiedTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_CampaignsGetDataList_CreatedTime, kn) {
					currentKey = ffj_t_CampaignsGetDataList_CreatedTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_CampaignsGetDataList_BudgetReachDate, kn) {
					currentKey = ffj_t_CampaignsGetDataList_BudgetReachDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_CampaignsGetDataList_DailyBudget, kn) {
					currentKey = ffj_t_CampaignsGetDataList_DailyBudget
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_CampaignsGetDataList_ProductType, kn) {
					currentKey = ffj_t_CampaignsGetDataList_ProductType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_CampaignsGetDataList_CampaignType, kn) {
					currentKey = ffj_t_CampaignsGetDataList_CampaignType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CampaignsGetDataList_ConfiguredStatus, kn) {
					currentKey = ffj_t_CampaignsGetDataList_ConfiguredStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_CampaignsGetDataList_CampaignName, kn) {
					currentKey = ffj_t_CampaignsGetDataList_CampaignName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_CampaignsGetDataList_CampaignID, kn) {
					currentKey = ffj_t_CampaignsGetDataList_CampaignID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_CampaignsGetDataListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_CampaignsGetDataList_CampaignID:
					goto handle_CampaignID

				case ffj_t_CampaignsGetDataList_CampaignName:
					goto handle_CampaignName

				case ffj_t_CampaignsGetDataList_ConfiguredStatus:
					goto handle_ConfiguredStatus

				case ffj_t_CampaignsGetDataList_CampaignType:
					goto handle_CampaignType

				case ffj_t_CampaignsGetDataList_ProductType:
					goto handle_ProductType

				case ffj_t_CampaignsGetDataList_DailyBudget:
					goto handle_DailyBudget

				case ffj_t_CampaignsGetDataList_BudgetReachDate:
					goto handle_BudgetReachDate

				case ffj_t_CampaignsGetDataList_CreatedTime:
					goto handle_CreatedTime

				case ffj_t_CampaignsGetDataList_LastModifiedTime:
					goto handle_LastModifiedTime

				case ffj_t_CampaignsGetDataListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_CampaignID:

	/* handler: uj.CampaignID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.CampaignID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CampaignName:

	/* handler: uj.CampaignName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.CampaignName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ConfiguredStatus:

	/* handler: uj.ConfiguredStatus type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ConfiguredStatus = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CampaignType:

	/* handler: uj.CampaignType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.CampaignType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProductType:

	/* handler: uj.ProductType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ProductType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DailyBudget:

	/* handler: uj.DailyBudget type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.DailyBudget = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BudgetReachDate:

	/* handler: uj.BudgetReachDate type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.BudgetReachDate = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CreatedTime:

	/* handler: uj.CreatedTime type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.CreatedTime = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastModifiedTime:

	/* handler: uj.LastModifiedTime type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.LastModifiedTime = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *CampaignsGetResponse) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *CampaignsGetResponse) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"code":`)
	fflib.FormatBits2(buf, uint64(mj.Code), 10, mj.Code < 0)
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(mj.Message))
	buf.WriteString(`,"data":`)

	{

		err = mj.Data.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_CampaignsGetResponsebase = iota
	ffj_t_CampaignsGetResponseno_such_key

	ffj_t_CampaignsGetResponse_Code

	ffj_t_CampaignsGetResponse_Message

	ffj_t_CampaignsGetResponse_Data
)

var ffj_key_CampaignsGetResponse_Code = []byte("code")

var ffj_key_CampaignsGetResponse_Message = []byte("message")

var ffj_key_CampaignsGetResponse_Data = []byte("data")

func (uj *CampaignsGetResponse) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *CampaignsGetResponse) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_CampaignsGetResponsebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_CampaignsGetResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_CampaignsGetResponse_Code, kn) {
						currentKey = ffj_t_CampaignsGetResponse_Code
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_CampaignsGetResponse_Data, kn) {
						currentKey = ffj_t_CampaignsGetResponse_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_CampaignsGetResponse_Message, kn) {
						currentKey = ffj_t_CampaignsGetResponse_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_CampaignsGetResponse_Data, kn) {
					currentKey = ffj_t_CampaignsGetResponse_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CampaignsGetResponse_Message, kn) {
					currentKey = ffj_t_CampaignsGetResponse_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CampaignsGetResponse_Code, kn) {
					currentKey = ffj_t_CampaignsGetResponse_Code
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_CampaignsGetResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_CampaignsGetResponse_Code:
					goto handle_Code

				case ffj_t_CampaignsGetResponse_Message:
					goto handle_Message

				case ffj_t_CampaignsGetResponse_Data:
					goto handle_Data

				case ffj_t_CampaignsGetResponseno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Code:

	/* handler: uj.Code type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Code = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=gdt.CampaignsGetData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Data.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *CorporateType) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *CorporateType) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"corporate_name":`)
	fflib.WriteJsonString(buf, string(mj.CorporateName))
	buf.WriteString(`,"corporate_img":`)
	fflib.WriteJsonString(buf, string(mj.CorporateImg))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_CorporateTypebase = iota
	ffj_t_CorporateTypeno_such_key

	ffj_t_CorporateType_CorporateName

	ffj_t_CorporateType_CorporateImg
)

var ffj_key_CorporateType_CorporateName = []byte("corporate_name")

var ffj_key_CorporateType_CorporateImg = []byte("corporate_img")

func (uj *CorporateType) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *CorporateType) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_CorporateTypebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_CorporateTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_CorporateType_CorporateName, kn) {
						currentKey = ffj_t_CorporateType_CorporateName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_CorporateType_CorporateImg, kn) {
						currentKey = ffj_t_CorporateType_CorporateImg
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_CorporateType_CorporateImg, kn) {
					currentKey = ffj_t_CorporateType_CorporateImg
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_CorporateType_CorporateName, kn) {
					currentKey = ffj_t_CorporateType_CorporateName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_CorporateTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_CorporateType_CorporateName:
					goto handle_CorporateName

				case ffj_t_CorporateType_CorporateImg:
					goto handle_CorporateImg

				case ffj_t_CorporateTypeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_CorporateName:

	/* handler: uj.CorporateName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.CorporateName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CorporateImg:

	/* handler: uj.CorporateImg type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.CorporateImg = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *DailyReportsGetData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *DailyReportsGetData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"list":`)
	if mj.List != nil {
		buf.WriteString(`[`)
		for i, v := range mj.List {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"page_info":`)

	{

		err = mj.PageInfo.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_DailyReportsGetDatabase = iota
	ffj_t_DailyReportsGetDatano_such_key

	ffj_t_DailyReportsGetData_List

	ffj_t_DailyReportsGetData_PageInfo
)

var ffj_key_DailyReportsGetData_List = []byte("list")

var ffj_key_DailyReportsGetData_PageInfo = []byte("page_info")

func (uj *DailyReportsGetData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *DailyReportsGetData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_DailyReportsGetDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_DailyReportsGetDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_DailyReportsGetData_List, kn) {
						currentKey = ffj_t_DailyReportsGetData_List
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_DailyReportsGetData_PageInfo, kn) {
						currentKey = ffj_t_DailyReportsGetData_PageInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_DailyReportsGetData_PageInfo, kn) {
					currentKey = ffj_t_DailyReportsGetData_PageInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_DailyReportsGetData_List, kn) {
					currentKey = ffj_t_DailyReportsGetData_List
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_DailyReportsGetDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_DailyReportsGetData_List:
					goto handle_List

				case ffj_t_DailyReportsGetData_PageInfo:
					goto handle_PageInfo

				case ffj_t_DailyReportsGetDatano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_List:

	/* handler: uj.List type=[]gdt.DailyReportsGetDataList kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.List = nil
		} else {

			uj.List = []DailyReportsGetDataList{}

			wantVal := true

			for {

				var tmp_uj__List DailyReportsGetDataList

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__List type=gdt.DailyReportsGetDataList kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__List.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.List = append(uj.List, tmp_uj__List)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PageInfo:

	/* handler: uj.PageInfo type=gdt.PageInfoData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.PageInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *DailyReportsGetDataList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *DailyReportsGetDataList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"date":`)
	fflib.WriteJsonString(buf, string(mj.Date))
	buf.WriteString(`,"campaign_id":`)
	fflib.FormatBits2(buf, uint64(mj.CampaignID), 10, mj.CampaignID < 0)
	buf.WriteString(`,"adgroup_id":`)
	fflib.FormatBits2(buf, uint64(mj.AdgroupID), 10, mj.AdgroupID < 0)
	buf.WriteString(`,"impression":`)
	fflib.FormatBits2(buf, uint64(mj.Impression), 10, mj.Impression < 0)
	buf.WriteString(`,"click":`)
	fflib.FormatBits2(buf, uint64(mj.Click), 10, mj.Click < 0)
	buf.WriteString(`,"cost":`)
	fflib.FormatBits2(buf, uint64(mj.Cost), 10, mj.Cost < 0)
	buf.WriteString(`,"download":`)
	fflib.FormatBits2(buf, uint64(mj.Download), 10, mj.Download < 0)
	buf.WriteString(`,"conversion":`)
	fflib.FormatBits2(buf, uint64(mj.Conversion), 10, mj.Conversion < 0)
	buf.WriteString(`,"activation":`)
	fflib.FormatBits2(buf, uint64(mj.Activation), 10, mj.Activation < 0)
	buf.WriteString(`,"like_or_comment":`)
	fflib.FormatBits2(buf, uint64(mj.LikeOrComment), 10, mj.LikeOrComment < 0)
	buf.WriteString(`,"image_click":`)
	fflib.FormatBits2(buf, uint64(mj.ImageClick), 10, mj.ImageClick < 0)
	buf.WriteString(`,"follow":`)
	fflib.FormatBits2(buf, uint64(mj.Follow), 10, mj.Follow < 0)
	buf.WriteString(`,"share":`)
	fflib.FormatBits2(buf, uint64(mj.Share), 10, mj.Share < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_DailyReportsGetDataListbase = iota
	ffj_t_DailyReportsGetDataListno_such_key

	ffj_t_DailyReportsGetDataList_Date

	ffj_t_DailyReportsGetDataList_CampaignID

	ffj_t_DailyReportsGetDataList_AdgroupID

	ffj_t_DailyReportsGetDataList_Impression

	ffj_t_DailyReportsGetDataList_Click

	ffj_t_DailyReportsGetDataList_Cost

	ffj_t_DailyReportsGetDataList_Download

	ffj_t_DailyReportsGetDataList_Conversion

	ffj_t_DailyReportsGetDataList_Activation

	ffj_t_DailyReportsGetDataList_LikeOrComment

	ffj_t_DailyReportsGetDataList_ImageClick

	ffj_t_DailyReportsGetDataList_Follow

	ffj_t_DailyReportsGetDataList_Share
)

var ffj_key_DailyReportsGetDataList_Date = []byte("date")

var ffj_key_DailyReportsGetDataList_CampaignID = []byte("campaign_id")

var ffj_key_DailyReportsGetDataList_AdgroupID = []byte("adgroup_id")

var ffj_key_DailyReportsGetDataList_Impression = []byte("impression")

var ffj_key_DailyReportsGetDataList_Click = []byte("click")

var ffj_key_DailyReportsGetDataList_Cost = []byte("cost")

var ffj_key_DailyReportsGetDataList_Download = []byte("download")

var ffj_key_DailyReportsGetDataList_Conversion = []byte("conversion")

var ffj_key_DailyReportsGetDataList_Activation = []byte("activation")

var ffj_key_DailyReportsGetDataList_LikeOrComment = []byte("like_or_comment")

var ffj_key_DailyReportsGetDataList_ImageClick = []byte("image_click")

var ffj_key_DailyReportsGetDataList_Follow = []byte("follow")

var ffj_key_DailyReportsGetDataList_Share = []byte("share")

func (uj *DailyReportsGetDataList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *DailyReportsGetDataList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_DailyReportsGetDataListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_DailyReportsGetDataListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_DailyReportsGetDataList_AdgroupID, kn) {
						currentKey = ffj_t_DailyReportsGetDataList_AdgroupID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_DailyReportsGetDataList_Activation, kn) {
						currentKey = ffj_t_DailyReportsGetDataList_Activation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_DailyReportsGetDataList_CampaignID, kn) {
						currentKey = ffj_t_DailyReportsGetDataList_CampaignID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_DailyReportsGetDataList_Click, kn) {
						currentKey = ffj_t_DailyReportsGetDataList_Click
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_DailyReportsGetDataList_Cost, kn) {
						currentKey = ffj_t_DailyReportsGetDataList_Cost
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_DailyReportsGetDataList_Conversion, kn) {
						currentKey = ffj_t_DailyReportsGetDataList_Conversion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_DailyReportsGetDataList_Date, kn) {
						currentKey = ffj_t_DailyReportsGetDataList_Date
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_DailyReportsGetDataList_Download, kn) {
						currentKey = ffj_t_DailyReportsGetDataList_Download
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_DailyReportsGetDataList_Follow, kn) {
						currentKey = ffj_t_DailyReportsGetDataList_Follow
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_DailyReportsGetDataList_Impression, kn) {
						currentKey = ffj_t_DailyReportsGetDataList_Impression
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_DailyReportsGetDataList_ImageClick, kn) {
						currentKey = ffj_t_DailyReportsGetDataList_ImageClick
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_DailyReportsGetDataList_LikeOrComment, kn) {
						currentKey = ffj_t_DailyReportsGetDataList_LikeOrComment
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_DailyReportsGetDataList_Share, kn) {
						currentKey = ffj_t_DailyReportsGetDataList_Share
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_DailyReportsGetDataList_Share, kn) {
					currentKey = ffj_t_DailyReportsGetDataList_Share
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_DailyReportsGetDataList_Follow, kn) {
					currentKey = ffj_t_DailyReportsGetDataList_Follow
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_DailyReportsGetDataList_ImageClick, kn) {
					currentKey = ffj_t_DailyReportsGetDataList_ImageClick
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_DailyReportsGetDataList_LikeOrComment, kn) {
					currentKey = ffj_t_DailyReportsGetDataList_LikeOrComment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_DailyReportsGetDataList_Activation, kn) {
					currentKey = ffj_t_DailyReportsGetDataList_Activation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_DailyReportsGetDataList_Conversion, kn) {
					currentKey = ffj_t_DailyReportsGetDataList_Conversion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_DailyReportsGetDataList_Download, kn) {
					currentKey = ffj_t_DailyReportsGetDataList_Download
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_DailyReportsGetDataList_Cost, kn) {
					currentKey = ffj_t_DailyReportsGetDataList_Cost
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_DailyReportsGetDataList_Click, kn) {
					currentKey = ffj_t_DailyReportsGetDataList_Click
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_DailyReportsGetDataList_Impression, kn) {
					currentKey = ffj_t_DailyReportsGetDataList_Impression
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_DailyReportsGetDataList_AdgroupID, kn) {
					currentKey = ffj_t_DailyReportsGetDataList_AdgroupID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_DailyReportsGetDataList_CampaignID, kn) {
					currentKey = ffj_t_DailyReportsGetDataList_CampaignID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_DailyReportsGetDataList_Date, kn) {
					currentKey = ffj_t_DailyReportsGetDataList_Date
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_DailyReportsGetDataListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_DailyReportsGetDataList_Date:
					goto handle_Date

				case ffj_t_DailyReportsGetDataList_CampaignID:
					goto handle_CampaignID

				case ffj_t_DailyReportsGetDataList_AdgroupID:
					goto handle_AdgroupID

				case ffj_t_DailyReportsGetDataList_Impression:
					goto handle_Impression

				case ffj_t_DailyReportsGetDataList_Click:
					goto handle_Click

				case ffj_t_DailyReportsGetDataList_Cost:
					goto handle_Cost

				case ffj_t_DailyReportsGetDataList_Download:
					goto handle_Download

				case ffj_t_DailyReportsGetDataList_Conversion:
					goto handle_Conversion

				case ffj_t_DailyReportsGetDataList_Activation:
					goto handle_Activation

				case ffj_t_DailyReportsGetDataList_LikeOrComment:
					goto handle_LikeOrComment

				case ffj_t_DailyReportsGetDataList_ImageClick:
					goto handle_ImageClick

				case ffj_t_DailyReportsGetDataList_Follow:
					goto handle_Follow

				case ffj_t_DailyReportsGetDataList_Share:
					goto handle_Share

				case ffj_t_DailyReportsGetDataListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Date:

	/* handler: uj.Date type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Date = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CampaignID:

	/* handler: uj.CampaignID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.CampaignID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AdgroupID:

	/* handler: uj.AdgroupID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.AdgroupID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Impression:

	/* handler: uj.Impression type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Impression = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Click:

	/* handler: uj.Click type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Click = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cost:

	/* handler: uj.Cost type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Cost = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Download:

	/* handler: uj.Download type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Download = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Conversion:

	/* handler: uj.Conversion type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Conversion = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Activation:

	/* handler: uj.Activation type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Activation = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LikeOrComment:

	/* handler: uj.LikeOrComment type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.LikeOrComment = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageClick:

	/* handler: uj.ImageClick type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ImageClick = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Follow:

	/* handler: uj.Follow type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Follow = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Share:

	/* handler: uj.Share type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Share = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *DailyReportsGetResponse) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *DailyReportsGetResponse) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"code":`)
	fflib.FormatBits2(buf, uint64(mj.Code), 10, mj.Code < 0)
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(mj.Message))
	buf.WriteString(`,"data":`)

	{

		err = mj.Data.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_DailyReportsGetResponsebase = iota
	ffj_t_DailyReportsGetResponseno_such_key

	ffj_t_DailyReportsGetResponse_Code

	ffj_t_DailyReportsGetResponse_Message

	ffj_t_DailyReportsGetResponse_Data
)

var ffj_key_DailyReportsGetResponse_Code = []byte("code")

var ffj_key_DailyReportsGetResponse_Message = []byte("message")

var ffj_key_DailyReportsGetResponse_Data = []byte("data")

func (uj *DailyReportsGetResponse) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *DailyReportsGetResponse) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_DailyReportsGetResponsebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_DailyReportsGetResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_DailyReportsGetResponse_Code, kn) {
						currentKey = ffj_t_DailyReportsGetResponse_Code
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_DailyReportsGetResponse_Data, kn) {
						currentKey = ffj_t_DailyReportsGetResponse_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_DailyReportsGetResponse_Message, kn) {
						currentKey = ffj_t_DailyReportsGetResponse_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_DailyReportsGetResponse_Data, kn) {
					currentKey = ffj_t_DailyReportsGetResponse_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_DailyReportsGetResponse_Message, kn) {
					currentKey = ffj_t_DailyReportsGetResponse_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_DailyReportsGetResponse_Code, kn) {
					currentKey = ffj_t_DailyReportsGetResponse_Code
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_DailyReportsGetResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_DailyReportsGetResponse_Code:
					goto handle_Code

				case ffj_t_DailyReportsGetResponse_Message:
					goto handle_Message

				case ffj_t_DailyReportsGetResponse_Data:
					goto handle_Data

				case ffj_t_DailyReportsGetResponseno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Code:

	/* handler: uj.Code type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Code = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=gdt.DailyReportsGetData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Data.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ElementStoryItemType) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ElementStoryItemType) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"image":`)
	fflib.WriteJsonString(buf, string(mj.Image))
	buf.WriteString(`,"image2":`)
	fflib.WriteJsonString(buf, string(mj.Image2))
	buf.WriteString(`,"description":`)
	fflib.WriteJsonString(buf, string(mj.Description))
	buf.WriteString(`,"url":`)
	fflib.WriteJsonString(buf, string(mj.Url))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(mj.Title))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ElementStoryItemTypebase = iota
	ffj_t_ElementStoryItemTypeno_such_key

	ffj_t_ElementStoryItemType_Image

	ffj_t_ElementStoryItemType_Image2

	ffj_t_ElementStoryItemType_Description

	ffj_t_ElementStoryItemType_Url

	ffj_t_ElementStoryItemType_Title
)

var ffj_key_ElementStoryItemType_Image = []byte("image")

var ffj_key_ElementStoryItemType_Image2 = []byte("image2")

var ffj_key_ElementStoryItemType_Description = []byte("description")

var ffj_key_ElementStoryItemType_Url = []byte("url")

var ffj_key_ElementStoryItemType_Title = []byte("title")

func (uj *ElementStoryItemType) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ElementStoryItemType) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ElementStoryItemTypebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ElementStoryItemTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_ElementStoryItemType_Description, kn) {
						currentKey = ffj_t_ElementStoryItemType_Description
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_ElementStoryItemType_Image, kn) {
						currentKey = ffj_t_ElementStoryItemType_Image
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ElementStoryItemType_Image2, kn) {
						currentKey = ffj_t_ElementStoryItemType_Image2
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_ElementStoryItemType_Title, kn) {
						currentKey = ffj_t_ElementStoryItemType_Title
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_ElementStoryItemType_Url, kn) {
						currentKey = ffj_t_ElementStoryItemType_Url
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ElementStoryItemType_Title, kn) {
					currentKey = ffj_t_ElementStoryItemType_Title
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ElementStoryItemType_Url, kn) {
					currentKey = ffj_t_ElementStoryItemType_Url
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ElementStoryItemType_Description, kn) {
					currentKey = ffj_t_ElementStoryItemType_Description
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ElementStoryItemType_Image2, kn) {
					currentKey = ffj_t_ElementStoryItemType_Image2
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ElementStoryItemType_Image, kn) {
					currentKey = ffj_t_ElementStoryItemType_Image
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ElementStoryItemTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ElementStoryItemType_Image:
					goto handle_Image

				case ffj_t_ElementStoryItemType_Image2:
					goto handle_Image2

				case ffj_t_ElementStoryItemType_Description:
					goto handle_Description

				case ffj_t_ElementStoryItemType_Url:
					goto handle_Url

				case ffj_t_ElementStoryItemType_Title:
					goto handle_Title

				case ffj_t_ElementStoryItemTypeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Image:

	/* handler: uj.Image type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Image = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Image2:

	/* handler: uj.Image2 type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Image2 = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: uj.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Url:

	/* handler: uj.Url type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Url = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: uj.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *GeoLocationType) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *GeoLocationType) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"location_types":`)
	if mj.LocationTypes != nil {
		buf.WriteString(`[`)
		for i, v := range mj.LocationTypes {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"regions":`)
	if mj.Regions != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Regions {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.FormatBits2(buf, uint64(v), 10, v < 0)
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"business_districts":`)
	if mj.BusinessDistricts != nil {
		buf.WriteString(`[`)
		for i, v := range mj.BusinessDistricts {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.FormatBits2(buf, uint64(v), 10, v < 0)
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_GeoLocationTypebase = iota
	ffj_t_GeoLocationTypeno_such_key

	ffj_t_GeoLocationType_LocationTypes

	ffj_t_GeoLocationType_Regions

	ffj_t_GeoLocationType_BusinessDistricts
)

var ffj_key_GeoLocationType_LocationTypes = []byte("location_types")

var ffj_key_GeoLocationType_Regions = []byte("regions")

var ffj_key_GeoLocationType_BusinessDistricts = []byte("business_districts")

func (uj *GeoLocationType) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *GeoLocationType) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_GeoLocationTypebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_GeoLocationTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffj_key_GeoLocationType_BusinessDistricts, kn) {
						currentKey = ffj_t_GeoLocationType_BusinessDistricts
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_GeoLocationType_LocationTypes, kn) {
						currentKey = ffj_t_GeoLocationType_LocationTypes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_GeoLocationType_Regions, kn) {
						currentKey = ffj_t_GeoLocationType_Regions
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_GeoLocationType_BusinessDistricts, kn) {
					currentKey = ffj_t_GeoLocationType_BusinessDistricts
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_GeoLocationType_Regions, kn) {
					currentKey = ffj_t_GeoLocationType_Regions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_GeoLocationType_LocationTypes, kn) {
					currentKey = ffj_t_GeoLocationType_LocationTypes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_GeoLocationTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_GeoLocationType_LocationTypes:
					goto handle_LocationTypes

				case ffj_t_GeoLocationType_Regions:
					goto handle_Regions

				case ffj_t_GeoLocationType_BusinessDistricts:
					goto handle_BusinessDistricts

				case ffj_t_GeoLocationTypeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_LocationTypes:

	/* handler: uj.LocationTypes type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.LocationTypes = nil
		} else {

			uj.LocationTypes = []string{}

			wantVal := true

			for {

				var tmp_uj__LocationTypes string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__LocationTypes type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__LocationTypes = string(string(outBuf))

					}
				}

				uj.LocationTypes = append(uj.LocationTypes, tmp_uj__LocationTypes)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Regions:

	/* handler: uj.Regions type=[]int64 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Regions = nil
		} else {

			uj.Regions = []int64{}

			wantVal := true

			for {

				var tmp_uj__Regions int64

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Regions type=int64 kind=int64 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmp_uj__Regions = int64(tval)

					}
				}

				uj.Regions = append(uj.Regions, tmp_uj__Regions)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BusinessDistricts:

	/* handler: uj.BusinessDistricts type=[]int64 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.BusinessDistricts = nil
		} else {

			uj.BusinessDistricts = []int64{}

			wantVal := true

			for {

				var tmp_uj__BusinessDistricts int64

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__BusinessDistricts type=int64 kind=int64 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmp_uj__BusinessDistricts = int64(tval)

					}
				}

				uj.BusinessDistricts = append(uj.BusinessDistricts, tmp_uj__BusinessDistricts)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *HourlyReportsGetData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *HourlyReportsGetData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"list":`)
	if mj.List != nil {
		buf.WriteString(`[`)
		for i, v := range mj.List {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"page_info":`)

	{

		err = mj.PageInfo.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_HourlyReportsGetDatabase = iota
	ffj_t_HourlyReportsGetDatano_such_key

	ffj_t_HourlyReportsGetData_List

	ffj_t_HourlyReportsGetData_PageInfo
)

var ffj_key_HourlyReportsGetData_List = []byte("list")

var ffj_key_HourlyReportsGetData_PageInfo = []byte("page_info")

func (uj *HourlyReportsGetData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *HourlyReportsGetData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_HourlyReportsGetDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_HourlyReportsGetDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_HourlyReportsGetData_List, kn) {
						currentKey = ffj_t_HourlyReportsGetData_List
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_HourlyReportsGetData_PageInfo, kn) {
						currentKey = ffj_t_HourlyReportsGetData_PageInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_HourlyReportsGetData_PageInfo, kn) {
					currentKey = ffj_t_HourlyReportsGetData_PageInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_HourlyReportsGetData_List, kn) {
					currentKey = ffj_t_HourlyReportsGetData_List
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_HourlyReportsGetDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_HourlyReportsGetData_List:
					goto handle_List

				case ffj_t_HourlyReportsGetData_PageInfo:
					goto handle_PageInfo

				case ffj_t_HourlyReportsGetDatano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_List:

	/* handler: uj.List type=[]gdt.HourlyReportsGetDataList kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.List = nil
		} else {

			uj.List = []HourlyReportsGetDataList{}

			wantVal := true

			for {

				var tmp_uj__List HourlyReportsGetDataList

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__List type=gdt.HourlyReportsGetDataList kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__List.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.List = append(uj.List, tmp_uj__List)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PageInfo:

	/* handler: uj.PageInfo type=gdt.PageInfoData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.PageInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *HourlyReportsGetDataList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *HourlyReportsGetDataList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"hour":`)
	fflib.FormatBits2(buf, uint64(mj.Hour), 10, mj.Hour < 0)
	buf.WriteString(`,"campaign_id":`)
	fflib.FormatBits2(buf, uint64(mj.CampaignID), 10, mj.CampaignID < 0)
	buf.WriteString(`,"adgroup_id":`)
	fflib.FormatBits2(buf, uint64(mj.AdgroupID), 10, mj.AdgroupID < 0)
	buf.WriteString(`,"impression":`)
	fflib.FormatBits2(buf, uint64(mj.Impression), 10, mj.Impression < 0)
	buf.WriteString(`,"click":`)
	fflib.FormatBits2(buf, uint64(mj.Click), 10, mj.Click < 0)
	buf.WriteString(`,"cost":`)
	fflib.FormatBits2(buf, uint64(mj.Cost), 10, mj.Cost < 0)
	buf.WriteString(`,"download":`)
	fflib.FormatBits2(buf, uint64(mj.Download), 10, mj.Download < 0)
	buf.WriteString(`,"conversion":`)
	fflib.FormatBits2(buf, uint64(mj.Conversion), 10, mj.Conversion < 0)
	buf.WriteString(`,"activation":`)
	fflib.FormatBits2(buf, uint64(mj.Activation), 10, mj.Activation < 0)
	buf.WriteString(`,"like_or_comment":`)
	fflib.FormatBits2(buf, uint64(mj.LikeOrComment), 10, mj.LikeOrComment < 0)
	buf.WriteString(`,"image_click":`)
	fflib.FormatBits2(buf, uint64(mj.ImageClick), 10, mj.ImageClick < 0)
	buf.WriteString(`,"follow":`)
	fflib.FormatBits2(buf, uint64(mj.Follow), 10, mj.Follow < 0)
	buf.WriteString(`,"share":`)
	fflib.FormatBits2(buf, uint64(mj.Share), 10, mj.Share < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_HourlyReportsGetDataListbase = iota
	ffj_t_HourlyReportsGetDataListno_such_key

	ffj_t_HourlyReportsGetDataList_Hour

	ffj_t_HourlyReportsGetDataList_CampaignID

	ffj_t_HourlyReportsGetDataList_AdgroupID

	ffj_t_HourlyReportsGetDataList_Impression

	ffj_t_HourlyReportsGetDataList_Click

	ffj_t_HourlyReportsGetDataList_Cost

	ffj_t_HourlyReportsGetDataList_Download

	ffj_t_HourlyReportsGetDataList_Conversion

	ffj_t_HourlyReportsGetDataList_Activation

	ffj_t_HourlyReportsGetDataList_LikeOrComment

	ffj_t_HourlyReportsGetDataList_ImageClick

	ffj_t_HourlyReportsGetDataList_Follow

	ffj_t_HourlyReportsGetDataList_Share
)

var ffj_key_HourlyReportsGetDataList_Hour = []byte("hour")

var ffj_key_HourlyReportsGetDataList_CampaignID = []byte("campaign_id")

var ffj_key_HourlyReportsGetDataList_AdgroupID = []byte("adgroup_id")

var ffj_key_HourlyReportsGetDataList_Impression = []byte("impression")

var ffj_key_HourlyReportsGetDataList_Click = []byte("click")

var ffj_key_HourlyReportsGetDataList_Cost = []byte("cost")

var ffj_key_HourlyReportsGetDataList_Download = []byte("download")

var ffj_key_HourlyReportsGetDataList_Conversion = []byte("conversion")

var ffj_key_HourlyReportsGetDataList_Activation = []byte("activation")

var ffj_key_HourlyReportsGetDataList_LikeOrComment = []byte("like_or_comment")

var ffj_key_HourlyReportsGetDataList_ImageClick = []byte("image_click")

var ffj_key_HourlyReportsGetDataList_Follow = []byte("follow")

var ffj_key_HourlyReportsGetDataList_Share = []byte("share")

func (uj *HourlyReportsGetDataList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *HourlyReportsGetDataList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_HourlyReportsGetDataListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_HourlyReportsGetDataListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_HourlyReportsGetDataList_AdgroupID, kn) {
						currentKey = ffj_t_HourlyReportsGetDataList_AdgroupID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_HourlyReportsGetDataList_Activation, kn) {
						currentKey = ffj_t_HourlyReportsGetDataList_Activation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_HourlyReportsGetDataList_CampaignID, kn) {
						currentKey = ffj_t_HourlyReportsGetDataList_CampaignID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_HourlyReportsGetDataList_Click, kn) {
						currentKey = ffj_t_HourlyReportsGetDataList_Click
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_HourlyReportsGetDataList_Cost, kn) {
						currentKey = ffj_t_HourlyReportsGetDataList_Cost
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_HourlyReportsGetDataList_Conversion, kn) {
						currentKey = ffj_t_HourlyReportsGetDataList_Conversion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_HourlyReportsGetDataList_Download, kn) {
						currentKey = ffj_t_HourlyReportsGetDataList_Download
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_HourlyReportsGetDataList_Follow, kn) {
						currentKey = ffj_t_HourlyReportsGetDataList_Follow
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_HourlyReportsGetDataList_Hour, kn) {
						currentKey = ffj_t_HourlyReportsGetDataList_Hour
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_HourlyReportsGetDataList_Impression, kn) {
						currentKey = ffj_t_HourlyReportsGetDataList_Impression
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_HourlyReportsGetDataList_ImageClick, kn) {
						currentKey = ffj_t_HourlyReportsGetDataList_ImageClick
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_HourlyReportsGetDataList_LikeOrComment, kn) {
						currentKey = ffj_t_HourlyReportsGetDataList_LikeOrComment
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_HourlyReportsGetDataList_Share, kn) {
						currentKey = ffj_t_HourlyReportsGetDataList_Share
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_HourlyReportsGetDataList_Share, kn) {
					currentKey = ffj_t_HourlyReportsGetDataList_Share
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_HourlyReportsGetDataList_Follow, kn) {
					currentKey = ffj_t_HourlyReportsGetDataList_Follow
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_HourlyReportsGetDataList_ImageClick, kn) {
					currentKey = ffj_t_HourlyReportsGetDataList_ImageClick
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_HourlyReportsGetDataList_LikeOrComment, kn) {
					currentKey = ffj_t_HourlyReportsGetDataList_LikeOrComment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_HourlyReportsGetDataList_Activation, kn) {
					currentKey = ffj_t_HourlyReportsGetDataList_Activation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_HourlyReportsGetDataList_Conversion, kn) {
					currentKey = ffj_t_HourlyReportsGetDataList_Conversion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_HourlyReportsGetDataList_Download, kn) {
					currentKey = ffj_t_HourlyReportsGetDataList_Download
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_HourlyReportsGetDataList_Cost, kn) {
					currentKey = ffj_t_HourlyReportsGetDataList_Cost
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_HourlyReportsGetDataList_Click, kn) {
					currentKey = ffj_t_HourlyReportsGetDataList_Click
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_HourlyReportsGetDataList_Impression, kn) {
					currentKey = ffj_t_HourlyReportsGetDataList_Impression
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_HourlyReportsGetDataList_AdgroupID, kn) {
					currentKey = ffj_t_HourlyReportsGetDataList_AdgroupID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_HourlyReportsGetDataList_CampaignID, kn) {
					currentKey = ffj_t_HourlyReportsGetDataList_CampaignID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_HourlyReportsGetDataList_Hour, kn) {
					currentKey = ffj_t_HourlyReportsGetDataList_Hour
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_HourlyReportsGetDataListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_HourlyReportsGetDataList_Hour:
					goto handle_Hour

				case ffj_t_HourlyReportsGetDataList_CampaignID:
					goto handle_CampaignID

				case ffj_t_HourlyReportsGetDataList_AdgroupID:
					goto handle_AdgroupID

				case ffj_t_HourlyReportsGetDataList_Impression:
					goto handle_Impression

				case ffj_t_HourlyReportsGetDataList_Click:
					goto handle_Click

				case ffj_t_HourlyReportsGetDataList_Cost:
					goto handle_Cost

				case ffj_t_HourlyReportsGetDataList_Download:
					goto handle_Download

				case ffj_t_HourlyReportsGetDataList_Conversion:
					goto handle_Conversion

				case ffj_t_HourlyReportsGetDataList_Activation:
					goto handle_Activation

				case ffj_t_HourlyReportsGetDataList_LikeOrComment:
					goto handle_LikeOrComment

				case ffj_t_HourlyReportsGetDataList_ImageClick:
					goto handle_ImageClick

				case ffj_t_HourlyReportsGetDataList_Follow:
					goto handle_Follow

				case ffj_t_HourlyReportsGetDataList_Share:
					goto handle_Share

				case ffj_t_HourlyReportsGetDataListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Hour:

	/* handler: uj.Hour type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Hour = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CampaignID:

	/* handler: uj.CampaignID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.CampaignID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AdgroupID:

	/* handler: uj.AdgroupID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.AdgroupID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Impression:

	/* handler: uj.Impression type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Impression = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Click:

	/* handler: uj.Click type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Click = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cost:

	/* handler: uj.Cost type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Cost = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Download:

	/* handler: uj.Download type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Download = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Conversion:

	/* handler: uj.Conversion type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Conversion = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Activation:

	/* handler: uj.Activation type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Activation = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LikeOrComment:

	/* handler: uj.LikeOrComment type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.LikeOrComment = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageClick:

	/* handler: uj.ImageClick type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ImageClick = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Follow:

	/* handler: uj.Follow type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Follow = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Share:

	/* handler: uj.Share type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Share = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *HourlyReportsGetResponse) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *HourlyReportsGetResponse) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"code":`)
	fflib.FormatBits2(buf, uint64(mj.Code), 10, mj.Code < 0)
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(mj.Message))
	buf.WriteString(`,"data":`)

	{

		err = mj.Data.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_HourlyReportsGetResponsebase = iota
	ffj_t_HourlyReportsGetResponseno_such_key

	ffj_t_HourlyReportsGetResponse_Code

	ffj_t_HourlyReportsGetResponse_Message

	ffj_t_HourlyReportsGetResponse_Data
)

var ffj_key_HourlyReportsGetResponse_Code = []byte("code")

var ffj_key_HourlyReportsGetResponse_Message = []byte("message")

var ffj_key_HourlyReportsGetResponse_Data = []byte("data")

func (uj *HourlyReportsGetResponse) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *HourlyReportsGetResponse) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_HourlyReportsGetResponsebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_HourlyReportsGetResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_HourlyReportsGetResponse_Code, kn) {
						currentKey = ffj_t_HourlyReportsGetResponse_Code
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_HourlyReportsGetResponse_Data, kn) {
						currentKey = ffj_t_HourlyReportsGetResponse_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_HourlyReportsGetResponse_Message, kn) {
						currentKey = ffj_t_HourlyReportsGetResponse_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_HourlyReportsGetResponse_Data, kn) {
					currentKey = ffj_t_HourlyReportsGetResponse_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_HourlyReportsGetResponse_Message, kn) {
					currentKey = ffj_t_HourlyReportsGetResponse_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_HourlyReportsGetResponse_Code, kn) {
					currentKey = ffj_t_HourlyReportsGetResponse_Code
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_HourlyReportsGetResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_HourlyReportsGetResponse_Code:
					goto handle_Code

				case ffj_t_HourlyReportsGetResponse_Message:
					goto handle_Message

				case ffj_t_HourlyReportsGetResponse_Data:
					goto handle_Data

				case ffj_t_HourlyReportsGetResponseno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Code:

	/* handler: uj.Code type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Code = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=gdt.HourlyReportsGetData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Data.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ImageCreateByUrlData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ImageCreateByUrlData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"image_id":`)
	fflib.WriteJsonString(buf, string(mj.ImageID))
	buf.WriteString(`,"image_width":`)
	fflib.FormatBits2(buf, uint64(mj.ImageWidth), 10, mj.ImageWidth < 0)
	buf.WriteString(`,"image_height":`)
	fflib.FormatBits2(buf, uint64(mj.ImageHeight), 10, mj.ImageHeight < 0)
	buf.WriteString(`,"image_file_size":`)
	fflib.FormatBits2(buf, uint64(mj.ImageFileSize), 10, mj.ImageFileSize < 0)
	buf.WriteString(`,"image_type":`)
	fflib.WriteJsonString(buf, string(mj.ImageType))
	buf.WriteString(`,"image_signature":`)
	fflib.WriteJsonString(buf, string(mj.ImageSignature))
	buf.WriteString(`,"outer_image_id":`)
	fflib.WriteJsonString(buf, string(mj.OuterImageID))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ImageCreateByUrlDatabase = iota
	ffj_t_ImageCreateByUrlDatano_such_key

	ffj_t_ImageCreateByUrlData_ImageID

	ffj_t_ImageCreateByUrlData_ImageWidth

	ffj_t_ImageCreateByUrlData_ImageHeight

	ffj_t_ImageCreateByUrlData_ImageFileSize

	ffj_t_ImageCreateByUrlData_ImageType

	ffj_t_ImageCreateByUrlData_ImageSignature

	ffj_t_ImageCreateByUrlData_OuterImageID
)

var ffj_key_ImageCreateByUrlData_ImageID = []byte("image_id")

var ffj_key_ImageCreateByUrlData_ImageWidth = []byte("image_width")

var ffj_key_ImageCreateByUrlData_ImageHeight = []byte("image_height")

var ffj_key_ImageCreateByUrlData_ImageFileSize = []byte("image_file_size")

var ffj_key_ImageCreateByUrlData_ImageType = []byte("image_type")

var ffj_key_ImageCreateByUrlData_ImageSignature = []byte("image_signature")

var ffj_key_ImageCreateByUrlData_OuterImageID = []byte("outer_image_id")

func (uj *ImageCreateByUrlData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ImageCreateByUrlData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ImageCreateByUrlDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ImageCreateByUrlDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_ImageCreateByUrlData_ImageID, kn) {
						currentKey = ffj_t_ImageCreateByUrlData_ImageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ImageCreateByUrlData_ImageWidth, kn) {
						currentKey = ffj_t_ImageCreateByUrlData_ImageWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ImageCreateByUrlData_ImageHeight, kn) {
						currentKey = ffj_t_ImageCreateByUrlData_ImageHeight
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ImageCreateByUrlData_ImageFileSize, kn) {
						currentKey = ffj_t_ImageCreateByUrlData_ImageFileSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ImageCreateByUrlData_ImageType, kn) {
						currentKey = ffj_t_ImageCreateByUrlData_ImageType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ImageCreateByUrlData_ImageSignature, kn) {
						currentKey = ffj_t_ImageCreateByUrlData_ImageSignature
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_ImageCreateByUrlData_OuterImageID, kn) {
						currentKey = ffj_t_ImageCreateByUrlData_OuterImageID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_ImageCreateByUrlData_OuterImageID, kn) {
					currentKey = ffj_t_ImageCreateByUrlData_OuterImageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ImageCreateByUrlData_ImageSignature, kn) {
					currentKey = ffj_t_ImageCreateByUrlData_ImageSignature
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ImageCreateByUrlData_ImageType, kn) {
					currentKey = ffj_t_ImageCreateByUrlData_ImageType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ImageCreateByUrlData_ImageFileSize, kn) {
					currentKey = ffj_t_ImageCreateByUrlData_ImageFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ImageCreateByUrlData_ImageHeight, kn) {
					currentKey = ffj_t_ImageCreateByUrlData_ImageHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ImageCreateByUrlData_ImageWidth, kn) {
					currentKey = ffj_t_ImageCreateByUrlData_ImageWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ImageCreateByUrlData_ImageID, kn) {
					currentKey = ffj_t_ImageCreateByUrlData_ImageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ImageCreateByUrlDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ImageCreateByUrlData_ImageID:
					goto handle_ImageID

				case ffj_t_ImageCreateByUrlData_ImageWidth:
					goto handle_ImageWidth

				case ffj_t_ImageCreateByUrlData_ImageHeight:
					goto handle_ImageHeight

				case ffj_t_ImageCreateByUrlData_ImageFileSize:
					goto handle_ImageFileSize

				case ffj_t_ImageCreateByUrlData_ImageType:
					goto handle_ImageType

				case ffj_t_ImageCreateByUrlData_ImageSignature:
					goto handle_ImageSignature

				case ffj_t_ImageCreateByUrlData_OuterImageID:
					goto handle_OuterImageID

				case ffj_t_ImageCreateByUrlDatano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ImageID:

	/* handler: uj.ImageID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ImageID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageWidth:

	/* handler: uj.ImageWidth type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ImageWidth = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageHeight:

	/* handler: uj.ImageHeight type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ImageHeight = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageFileSize:

	/* handler: uj.ImageFileSize type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ImageFileSize = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageType:

	/* handler: uj.ImageType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ImageType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageSignature:

	/* handler: uj.ImageSignature type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ImageSignature = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OuterImageID:

	/* handler: uj.OuterImageID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.OuterImageID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ImageCreateByUrlResponse) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ImageCreateByUrlResponse) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"code":`)
	fflib.FormatBits2(buf, uint64(mj.Code), 10, mj.Code < 0)
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(mj.Message))
	buf.WriteString(`,"data":`)

	{

		err = mj.Data.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ImageCreateByUrlResponsebase = iota
	ffj_t_ImageCreateByUrlResponseno_such_key

	ffj_t_ImageCreateByUrlResponse_Code

	ffj_t_ImageCreateByUrlResponse_Message

	ffj_t_ImageCreateByUrlResponse_Data
)

var ffj_key_ImageCreateByUrlResponse_Code = []byte("code")

var ffj_key_ImageCreateByUrlResponse_Message = []byte("message")

var ffj_key_ImageCreateByUrlResponse_Data = []byte("data")

func (uj *ImageCreateByUrlResponse) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ImageCreateByUrlResponse) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ImageCreateByUrlResponsebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ImageCreateByUrlResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ImageCreateByUrlResponse_Code, kn) {
						currentKey = ffj_t_ImageCreateByUrlResponse_Code
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_ImageCreateByUrlResponse_Data, kn) {
						currentKey = ffj_t_ImageCreateByUrlResponse_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ImageCreateByUrlResponse_Message, kn) {
						currentKey = ffj_t_ImageCreateByUrlResponse_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ImageCreateByUrlResponse_Data, kn) {
					currentKey = ffj_t_ImageCreateByUrlResponse_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ImageCreateByUrlResponse_Message, kn) {
					currentKey = ffj_t_ImageCreateByUrlResponse_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ImageCreateByUrlResponse_Code, kn) {
					currentKey = ffj_t_ImageCreateByUrlResponse_Code
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ImageCreateByUrlResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ImageCreateByUrlResponse_Code:
					goto handle_Code

				case ffj_t_ImageCreateByUrlResponse_Message:
					goto handle_Message

				case ffj_t_ImageCreateByUrlResponse_Data:
					goto handle_Data

				case ffj_t_ImageCreateByUrlResponseno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Code:

	/* handler: uj.Code type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Code = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=gdt.ImageCreateByUrlData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Data.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ImageCreateData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ImageCreateData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"image_id":`)
	fflib.WriteJsonString(buf, string(mj.ImageID))
	buf.WriteString(`,"image_width":`)
	fflib.FormatBits2(buf, uint64(mj.ImageWidth), 10, mj.ImageWidth < 0)
	buf.WriteString(`,"image_height":`)
	fflib.FormatBits2(buf, uint64(mj.ImageHeight), 10, mj.ImageHeight < 0)
	buf.WriteString(`,"image_file_size":`)
	fflib.FormatBits2(buf, uint64(mj.ImageFileSize), 10, mj.ImageFileSize < 0)
	buf.WriteString(`,"image_type":`)
	fflib.WriteJsonString(buf, string(mj.ImageType))
	buf.WriteString(`,"image_signature":`)
	fflib.WriteJsonString(buf, string(mj.ImageSignature))
	buf.WriteString(`,"outer_image_id":`)
	fflib.WriteJsonString(buf, string(mj.OuterImageID))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ImageCreateDatabase = iota
	ffj_t_ImageCreateDatano_such_key

	ffj_t_ImageCreateData_ImageID

	ffj_t_ImageCreateData_ImageWidth

	ffj_t_ImageCreateData_ImageHeight

	ffj_t_ImageCreateData_ImageFileSize

	ffj_t_ImageCreateData_ImageType

	ffj_t_ImageCreateData_ImageSignature

	ffj_t_ImageCreateData_OuterImageID
)

var ffj_key_ImageCreateData_ImageID = []byte("image_id")

var ffj_key_ImageCreateData_ImageWidth = []byte("image_width")

var ffj_key_ImageCreateData_ImageHeight = []byte("image_height")

var ffj_key_ImageCreateData_ImageFileSize = []byte("image_file_size")

var ffj_key_ImageCreateData_ImageType = []byte("image_type")

var ffj_key_ImageCreateData_ImageSignature = []byte("image_signature")

var ffj_key_ImageCreateData_OuterImageID = []byte("outer_image_id")

func (uj *ImageCreateData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ImageCreateData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ImageCreateDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ImageCreateDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_ImageCreateData_ImageID, kn) {
						currentKey = ffj_t_ImageCreateData_ImageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ImageCreateData_ImageWidth, kn) {
						currentKey = ffj_t_ImageCreateData_ImageWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ImageCreateData_ImageHeight, kn) {
						currentKey = ffj_t_ImageCreateData_ImageHeight
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ImageCreateData_ImageFileSize, kn) {
						currentKey = ffj_t_ImageCreateData_ImageFileSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ImageCreateData_ImageType, kn) {
						currentKey = ffj_t_ImageCreateData_ImageType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ImageCreateData_ImageSignature, kn) {
						currentKey = ffj_t_ImageCreateData_ImageSignature
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_ImageCreateData_OuterImageID, kn) {
						currentKey = ffj_t_ImageCreateData_OuterImageID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_ImageCreateData_OuterImageID, kn) {
					currentKey = ffj_t_ImageCreateData_OuterImageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ImageCreateData_ImageSignature, kn) {
					currentKey = ffj_t_ImageCreateData_ImageSignature
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ImageCreateData_ImageType, kn) {
					currentKey = ffj_t_ImageCreateData_ImageType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ImageCreateData_ImageFileSize, kn) {
					currentKey = ffj_t_ImageCreateData_ImageFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ImageCreateData_ImageHeight, kn) {
					currentKey = ffj_t_ImageCreateData_ImageHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ImageCreateData_ImageWidth, kn) {
					currentKey = ffj_t_ImageCreateData_ImageWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ImageCreateData_ImageID, kn) {
					currentKey = ffj_t_ImageCreateData_ImageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ImageCreateDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ImageCreateData_ImageID:
					goto handle_ImageID

				case ffj_t_ImageCreateData_ImageWidth:
					goto handle_ImageWidth

				case ffj_t_ImageCreateData_ImageHeight:
					goto handle_ImageHeight

				case ffj_t_ImageCreateData_ImageFileSize:
					goto handle_ImageFileSize

				case ffj_t_ImageCreateData_ImageType:
					goto handle_ImageType

				case ffj_t_ImageCreateData_ImageSignature:
					goto handle_ImageSignature

				case ffj_t_ImageCreateData_OuterImageID:
					goto handle_OuterImageID

				case ffj_t_ImageCreateDatano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ImageID:

	/* handler: uj.ImageID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ImageID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageWidth:

	/* handler: uj.ImageWidth type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ImageWidth = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageHeight:

	/* handler: uj.ImageHeight type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ImageHeight = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageFileSize:

	/* handler: uj.ImageFileSize type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ImageFileSize = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageType:

	/* handler: uj.ImageType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ImageType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageSignature:

	/* handler: uj.ImageSignature type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ImageSignature = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OuterImageID:

	/* handler: uj.OuterImageID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.OuterImageID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ImageCreateResponse) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ImageCreateResponse) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"code":`)
	fflib.FormatBits2(buf, uint64(mj.Code), 10, mj.Code < 0)
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(mj.Message))
	buf.WriteString(`,"data":`)

	{

		err = mj.Data.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ImageCreateResponsebase = iota
	ffj_t_ImageCreateResponseno_such_key

	ffj_t_ImageCreateResponse_Code

	ffj_t_ImageCreateResponse_Message

	ffj_t_ImageCreateResponse_Data
)

var ffj_key_ImageCreateResponse_Code = []byte("code")

var ffj_key_ImageCreateResponse_Message = []byte("message")

var ffj_key_ImageCreateResponse_Data = []byte("data")

func (uj *ImageCreateResponse) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ImageCreateResponse) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ImageCreateResponsebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ImageCreateResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ImageCreateResponse_Code, kn) {
						currentKey = ffj_t_ImageCreateResponse_Code
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_ImageCreateResponse_Data, kn) {
						currentKey = ffj_t_ImageCreateResponse_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ImageCreateResponse_Message, kn) {
						currentKey = ffj_t_ImageCreateResponse_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ImageCreateResponse_Data, kn) {
					currentKey = ffj_t_ImageCreateResponse_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ImageCreateResponse_Message, kn) {
					currentKey = ffj_t_ImageCreateResponse_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ImageCreateResponse_Code, kn) {
					currentKey = ffj_t_ImageCreateResponse_Code
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ImageCreateResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ImageCreateResponse_Code:
					goto handle_Code

				case ffj_t_ImageCreateResponse_Message:
					goto handle_Message

				case ffj_t_ImageCreateResponse_Data:
					goto handle_Data

				case ffj_t_ImageCreateResponseno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Code:

	/* handler: uj.Code type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Code = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=gdt.ImageCreateData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Data.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ImageReadData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ImageReadData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"image_id":`)
	fflib.WriteJsonString(buf, string(mj.ImageID))
	buf.WriteString(`,"image_width":`)
	fflib.FormatBits2(buf, uint64(mj.ImageWidth), 10, mj.ImageWidth < 0)
	buf.WriteString(`,"image_height":`)
	fflib.FormatBits2(buf, uint64(mj.ImageHeight), 10, mj.ImageHeight < 0)
	buf.WriteString(`,"image_file_size":`)
	fflib.FormatBits2(buf, uint64(mj.ImageFileSize), 10, mj.ImageFileSize < 0)
	buf.WriteString(`,"image_type":`)
	fflib.WriteJsonString(buf, string(mj.ImageType))
	buf.WriteString(`,"image_signature":`)
	fflib.WriteJsonString(buf, string(mj.ImageSignature))
	buf.WriteString(`,"preview_url":`)
	fflib.WriteJsonString(buf, string(mj.PreviewURL))
	buf.WriteString(`,"outer_image_id":`)
	fflib.WriteJsonString(buf, string(mj.OuterImageID))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ImageReadDatabase = iota
	ffj_t_ImageReadDatano_such_key

	ffj_t_ImageReadData_ImageID

	ffj_t_ImageReadData_ImageWidth

	ffj_t_ImageReadData_ImageHeight

	ffj_t_ImageReadData_ImageFileSize

	ffj_t_ImageReadData_ImageType

	ffj_t_ImageReadData_ImageSignature

	ffj_t_ImageReadData_PreviewURL

	ffj_t_ImageReadData_OuterImageID
)

var ffj_key_ImageReadData_ImageID = []byte("image_id")

var ffj_key_ImageReadData_ImageWidth = []byte("image_width")

var ffj_key_ImageReadData_ImageHeight = []byte("image_height")

var ffj_key_ImageReadData_ImageFileSize = []byte("image_file_size")

var ffj_key_ImageReadData_ImageType = []byte("image_type")

var ffj_key_ImageReadData_ImageSignature = []byte("image_signature")

var ffj_key_ImageReadData_PreviewURL = []byte("preview_url")

var ffj_key_ImageReadData_OuterImageID = []byte("outer_image_id")

func (uj *ImageReadData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ImageReadData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ImageReadDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ImageReadDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_ImageReadData_ImageID, kn) {
						currentKey = ffj_t_ImageReadData_ImageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ImageReadData_ImageWidth, kn) {
						currentKey = ffj_t_ImageReadData_ImageWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ImageReadData_ImageHeight, kn) {
						currentKey = ffj_t_ImageReadData_ImageHeight
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ImageReadData_ImageFileSize, kn) {
						currentKey = ffj_t_ImageReadData_ImageFileSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ImageReadData_ImageType, kn) {
						currentKey = ffj_t_ImageReadData_ImageType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ImageReadData_ImageSignature, kn) {
						currentKey = ffj_t_ImageReadData_ImageSignature
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_ImageReadData_OuterImageID, kn) {
						currentKey = ffj_t_ImageReadData_OuterImageID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_ImageReadData_PreviewURL, kn) {
						currentKey = ffj_t_ImageReadData_PreviewURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_ImageReadData_OuterImageID, kn) {
					currentKey = ffj_t_ImageReadData_OuterImageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ImageReadData_PreviewURL, kn) {
					currentKey = ffj_t_ImageReadData_PreviewURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ImageReadData_ImageSignature, kn) {
					currentKey = ffj_t_ImageReadData_ImageSignature
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ImageReadData_ImageType, kn) {
					currentKey = ffj_t_ImageReadData_ImageType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ImageReadData_ImageFileSize, kn) {
					currentKey = ffj_t_ImageReadData_ImageFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ImageReadData_ImageHeight, kn) {
					currentKey = ffj_t_ImageReadData_ImageHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ImageReadData_ImageWidth, kn) {
					currentKey = ffj_t_ImageReadData_ImageWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ImageReadData_ImageID, kn) {
					currentKey = ffj_t_ImageReadData_ImageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ImageReadDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ImageReadData_ImageID:
					goto handle_ImageID

				case ffj_t_ImageReadData_ImageWidth:
					goto handle_ImageWidth

				case ffj_t_ImageReadData_ImageHeight:
					goto handle_ImageHeight

				case ffj_t_ImageReadData_ImageFileSize:
					goto handle_ImageFileSize

				case ffj_t_ImageReadData_ImageType:
					goto handle_ImageType

				case ffj_t_ImageReadData_ImageSignature:
					goto handle_ImageSignature

				case ffj_t_ImageReadData_PreviewURL:
					goto handle_PreviewURL

				case ffj_t_ImageReadData_OuterImageID:
					goto handle_OuterImageID

				case ffj_t_ImageReadDatano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ImageID:

	/* handler: uj.ImageID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ImageID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageWidth:

	/* handler: uj.ImageWidth type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ImageWidth = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageHeight:

	/* handler: uj.ImageHeight type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ImageHeight = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageFileSize:

	/* handler: uj.ImageFileSize type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ImageFileSize = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageType:

	/* handler: uj.ImageType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ImageType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageSignature:

	/* handler: uj.ImageSignature type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ImageSignature = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PreviewURL:

	/* handler: uj.PreviewURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.PreviewURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OuterImageID:

	/* handler: uj.OuterImageID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.OuterImageID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ImageReadResponse) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ImageReadResponse) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"code":`)
	fflib.FormatBits2(buf, uint64(mj.Code), 10, mj.Code < 0)
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(mj.Message))
	buf.WriteString(`,"data":`)

	{

		err = mj.Data.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ImageReadResponsebase = iota
	ffj_t_ImageReadResponseno_such_key

	ffj_t_ImageReadResponse_Code

	ffj_t_ImageReadResponse_Message

	ffj_t_ImageReadResponse_Data
)

var ffj_key_ImageReadResponse_Code = []byte("code")

var ffj_key_ImageReadResponse_Message = []byte("message")

var ffj_key_ImageReadResponse_Data = []byte("data")

func (uj *ImageReadResponse) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ImageReadResponse) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ImageReadResponsebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ImageReadResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ImageReadResponse_Code, kn) {
						currentKey = ffj_t_ImageReadResponse_Code
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_ImageReadResponse_Data, kn) {
						currentKey = ffj_t_ImageReadResponse_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ImageReadResponse_Message, kn) {
						currentKey = ffj_t_ImageReadResponse_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ImageReadResponse_Data, kn) {
					currentKey = ffj_t_ImageReadResponse_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ImageReadResponse_Message, kn) {
					currentKey = ffj_t_ImageReadResponse_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ImageReadResponse_Code, kn) {
					currentKey = ffj_t_ImageReadResponse_Code
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ImageReadResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ImageReadResponse_Code:
					goto handle_Code

				case ffj_t_ImageReadResponse_Message:
					goto handle_Message

				case ffj_t_ImageReadResponse_Data:
					goto handle_Data

				case ffj_t_ImageReadResponseno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Code:

	/* handler: uj.Code type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Code = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=gdt.ImageReadData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Data.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ImageSelectData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ImageSelectData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"list":`)
	if mj.List != nil {
		buf.WriteString(`[`)
		for i, v := range mj.List {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"page_info":`)

	{

		err = mj.PageInfo.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ImageSelectDatabase = iota
	ffj_t_ImageSelectDatano_such_key

	ffj_t_ImageSelectData_List

	ffj_t_ImageSelectData_PageInfo
)

var ffj_key_ImageSelectData_List = []byte("list")

var ffj_key_ImageSelectData_PageInfo = []byte("page_info")

func (uj *ImageSelectData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ImageSelectData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ImageSelectDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ImageSelectDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_ImageSelectData_List, kn) {
						currentKey = ffj_t_ImageSelectData_List
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_ImageSelectData_PageInfo, kn) {
						currentKey = ffj_t_ImageSelectData_PageInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_ImageSelectData_PageInfo, kn) {
					currentKey = ffj_t_ImageSelectData_PageInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ImageSelectData_List, kn) {
					currentKey = ffj_t_ImageSelectData_List
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ImageSelectDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ImageSelectData_List:
					goto handle_List

				case ffj_t_ImageSelectData_PageInfo:
					goto handle_PageInfo

				case ffj_t_ImageSelectDatano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_List:

	/* handler: uj.List type=[]gdt.ImageSelectDataList kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.List = nil
		} else {

			uj.List = []ImageSelectDataList{}

			wantVal := true

			for {

				var tmp_uj__List ImageSelectDataList

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__List type=gdt.ImageSelectDataList kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__List.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.List = append(uj.List, tmp_uj__List)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PageInfo:

	/* handler: uj.PageInfo type=gdt.PageInfoData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.PageInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ImageSelectDataList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ImageSelectDataList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"image_id":`)
	fflib.WriteJsonString(buf, string(mj.ImageID))
	buf.WriteString(`,"image_width":`)
	fflib.FormatBits2(buf, uint64(mj.ImageWidth), 10, mj.ImageWidth < 0)
	buf.WriteString(`,"image_height":`)
	fflib.FormatBits2(buf, uint64(mj.ImageHeight), 10, mj.ImageHeight < 0)
	buf.WriteString(`,"image_file_size":`)
	fflib.FormatBits2(buf, uint64(mj.ImageFileSize), 10, mj.ImageFileSize < 0)
	buf.WriteString(`,"image_type":`)
	fflib.WriteJsonString(buf, string(mj.ImageType))
	buf.WriteString(`,"image_signature":`)
	fflib.WriteJsonString(buf, string(mj.ImageSignature))
	buf.WriteString(`,"preview_url":`)
	fflib.WriteJsonString(buf, string(mj.PreviewURL))
	buf.WriteString(`,"outer_image_id":`)
	fflib.WriteJsonString(buf, string(mj.OuterImageID))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ImageSelectDataListbase = iota
	ffj_t_ImageSelectDataListno_such_key

	ffj_t_ImageSelectDataList_ImageID

	ffj_t_ImageSelectDataList_ImageWidth

	ffj_t_ImageSelectDataList_ImageHeight

	ffj_t_ImageSelectDataList_ImageFileSize

	ffj_t_ImageSelectDataList_ImageType

	ffj_t_ImageSelectDataList_ImageSignature

	ffj_t_ImageSelectDataList_PreviewURL

	ffj_t_ImageSelectDataList_OuterImageID
)

var ffj_key_ImageSelectDataList_ImageID = []byte("image_id")

var ffj_key_ImageSelectDataList_ImageWidth = []byte("image_width")

var ffj_key_ImageSelectDataList_ImageHeight = []byte("image_height")

var ffj_key_ImageSelectDataList_ImageFileSize = []byte("image_file_size")

var ffj_key_ImageSelectDataList_ImageType = []byte("image_type")

var ffj_key_ImageSelectDataList_ImageSignature = []byte("image_signature")

var ffj_key_ImageSelectDataList_PreviewURL = []byte("preview_url")

var ffj_key_ImageSelectDataList_OuterImageID = []byte("outer_image_id")

func (uj *ImageSelectDataList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ImageSelectDataList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ImageSelectDataListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ImageSelectDataListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_ImageSelectDataList_ImageID, kn) {
						currentKey = ffj_t_ImageSelectDataList_ImageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ImageSelectDataList_ImageWidth, kn) {
						currentKey = ffj_t_ImageSelectDataList_ImageWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ImageSelectDataList_ImageHeight, kn) {
						currentKey = ffj_t_ImageSelectDataList_ImageHeight
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ImageSelectDataList_ImageFileSize, kn) {
						currentKey = ffj_t_ImageSelectDataList_ImageFileSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ImageSelectDataList_ImageType, kn) {
						currentKey = ffj_t_ImageSelectDataList_ImageType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ImageSelectDataList_ImageSignature, kn) {
						currentKey = ffj_t_ImageSelectDataList_ImageSignature
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_ImageSelectDataList_OuterImageID, kn) {
						currentKey = ffj_t_ImageSelectDataList_OuterImageID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_ImageSelectDataList_PreviewURL, kn) {
						currentKey = ffj_t_ImageSelectDataList_PreviewURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_ImageSelectDataList_OuterImageID, kn) {
					currentKey = ffj_t_ImageSelectDataList_OuterImageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ImageSelectDataList_PreviewURL, kn) {
					currentKey = ffj_t_ImageSelectDataList_PreviewURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ImageSelectDataList_ImageSignature, kn) {
					currentKey = ffj_t_ImageSelectDataList_ImageSignature
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ImageSelectDataList_ImageType, kn) {
					currentKey = ffj_t_ImageSelectDataList_ImageType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ImageSelectDataList_ImageFileSize, kn) {
					currentKey = ffj_t_ImageSelectDataList_ImageFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ImageSelectDataList_ImageHeight, kn) {
					currentKey = ffj_t_ImageSelectDataList_ImageHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ImageSelectDataList_ImageWidth, kn) {
					currentKey = ffj_t_ImageSelectDataList_ImageWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ImageSelectDataList_ImageID, kn) {
					currentKey = ffj_t_ImageSelectDataList_ImageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ImageSelectDataListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ImageSelectDataList_ImageID:
					goto handle_ImageID

				case ffj_t_ImageSelectDataList_ImageWidth:
					goto handle_ImageWidth

				case ffj_t_ImageSelectDataList_ImageHeight:
					goto handle_ImageHeight

				case ffj_t_ImageSelectDataList_ImageFileSize:
					goto handle_ImageFileSize

				case ffj_t_ImageSelectDataList_ImageType:
					goto handle_ImageType

				case ffj_t_ImageSelectDataList_ImageSignature:
					goto handle_ImageSignature

				case ffj_t_ImageSelectDataList_PreviewURL:
					goto handle_PreviewURL

				case ffj_t_ImageSelectDataList_OuterImageID:
					goto handle_OuterImageID

				case ffj_t_ImageSelectDataListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ImageID:

	/* handler: uj.ImageID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ImageID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageWidth:

	/* handler: uj.ImageWidth type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ImageWidth = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageHeight:

	/* handler: uj.ImageHeight type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ImageHeight = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageFileSize:

	/* handler: uj.ImageFileSize type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ImageFileSize = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageType:

	/* handler: uj.ImageType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ImageType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageSignature:

	/* handler: uj.ImageSignature type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ImageSignature = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PreviewURL:

	/* handler: uj.PreviewURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.PreviewURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OuterImageID:

	/* handler: uj.OuterImageID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.OuterImageID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ImageSelectResponse) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ImageSelectResponse) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"code":`)
	fflib.FormatBits2(buf, uint64(mj.Code), 10, mj.Code < 0)
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(mj.Message))
	buf.WriteString(`,"data":`)

	{

		err = mj.Data.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ImageSelectResponsebase = iota
	ffj_t_ImageSelectResponseno_such_key

	ffj_t_ImageSelectResponse_Code

	ffj_t_ImageSelectResponse_Message

	ffj_t_ImageSelectResponse_Data
)

var ffj_key_ImageSelectResponse_Code = []byte("code")

var ffj_key_ImageSelectResponse_Message = []byte("message")

var ffj_key_ImageSelectResponse_Data = []byte("data")

func (uj *ImageSelectResponse) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ImageSelectResponse) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ImageSelectResponsebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ImageSelectResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ImageSelectResponse_Code, kn) {
						currentKey = ffj_t_ImageSelectResponse_Code
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_ImageSelectResponse_Data, kn) {
						currentKey = ffj_t_ImageSelectResponse_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ImageSelectResponse_Message, kn) {
						currentKey = ffj_t_ImageSelectResponse_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ImageSelectResponse_Data, kn) {
					currentKey = ffj_t_ImageSelectResponse_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ImageSelectResponse_Message, kn) {
					currentKey = ffj_t_ImageSelectResponse_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ImageSelectResponse_Code, kn) {
					currentKey = ffj_t_ImageSelectResponse_Code
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ImageSelectResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ImageSelectResponse_Code:
					goto handle_Code

				case ffj_t_ImageSelectResponse_Message:
					goto handle_Message

				case ffj_t_ImageSelectResponse_Data:
					goto handle_Data

				case ffj_t_ImageSelectResponseno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Code:

	/* handler: uj.Code type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Code = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=gdt.ImageSelectData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Data.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *KeywordsType) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *KeywordsType) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"words":`)
	if mj.Words != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Words {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_KeywordsTypebase = iota
	ffj_t_KeywordsTypeno_such_key

	ffj_t_KeywordsType_Words
)

var ffj_key_KeywordsType_Words = []byte("words")

func (uj *KeywordsType) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *KeywordsType) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_KeywordsTypebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_KeywordsTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'w':

					if bytes.Equal(ffj_key_KeywordsType_Words, kn) {
						currentKey = ffj_t_KeywordsType_Words
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_KeywordsType_Words, kn) {
					currentKey = ffj_t_KeywordsType_Words
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_KeywordsTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_KeywordsType_Words:
					goto handle_Words

				case ffj_t_KeywordsTypeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Words:

	/* handler: uj.Words type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Words = nil
		} else {

			uj.Words = []string{}

			wantVal := true

			for {

				var tmp_uj__Words string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Words type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__Words = string(string(outBuf))

					}
				}

				uj.Words = append(uj.Words, tmp_uj__Words)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *MediaCreateData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MediaCreateData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"media_id":`)
	fflib.WriteJsonString(buf, string(mj.MediaID))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MediaCreateDatabase = iota
	ffj_t_MediaCreateDatano_such_key

	ffj_t_MediaCreateData_MediaID
)

var ffj_key_MediaCreateData_MediaID = []byte("media_id")

func (uj *MediaCreateData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MediaCreateData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MediaCreateDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MediaCreateDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'm':

					if bytes.Equal(ffj_key_MediaCreateData_MediaID, kn) {
						currentKey = ffj_t_MediaCreateData_MediaID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_MediaCreateData_MediaID, kn) {
					currentKey = ffj_t_MediaCreateData_MediaID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MediaCreateDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MediaCreateData_MediaID:
					goto handle_MediaID

				case ffj_t_MediaCreateDatano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_MediaID:

	/* handler: uj.MediaID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.MediaID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *MediaCreateResponse) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MediaCreateResponse) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"code":`)
	fflib.FormatBits2(buf, uint64(mj.Code), 10, mj.Code < 0)
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(mj.Message))
	buf.WriteString(`,"data":`)

	{

		err = mj.Data.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MediaCreateResponsebase = iota
	ffj_t_MediaCreateResponseno_such_key

	ffj_t_MediaCreateResponse_Code

	ffj_t_MediaCreateResponse_Message

	ffj_t_MediaCreateResponse_Data
)

var ffj_key_MediaCreateResponse_Code = []byte("code")

var ffj_key_MediaCreateResponse_Message = []byte("message")

var ffj_key_MediaCreateResponse_Data = []byte("data")

func (uj *MediaCreateResponse) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MediaCreateResponse) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MediaCreateResponsebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MediaCreateResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_MediaCreateResponse_Code, kn) {
						currentKey = ffj_t_MediaCreateResponse_Code
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_MediaCreateResponse_Data, kn) {
						currentKey = ffj_t_MediaCreateResponse_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_MediaCreateResponse_Message, kn) {
						currentKey = ffj_t_MediaCreateResponse_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_MediaCreateResponse_Data, kn) {
					currentKey = ffj_t_MediaCreateResponse_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MediaCreateResponse_Message, kn) {
					currentKey = ffj_t_MediaCreateResponse_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MediaCreateResponse_Code, kn) {
					currentKey = ffj_t_MediaCreateResponse_Code
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MediaCreateResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MediaCreateResponse_Code:
					goto handle_Code

				case ffj_t_MediaCreateResponse_Message:
					goto handle_Message

				case ffj_t_MediaCreateResponse_Data:
					goto handle_Data

				case ffj_t_MediaCreateResponseno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Code:

	/* handler: uj.Code type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Code = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=gdt.MediaCreateData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Data.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *MediaReadData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MediaReadData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"media_description":`)
	fflib.WriteJsonString(buf, string(mj.MediaDescription))
	buf.WriteString(`,"media_width":`)
	fflib.FormatBits2(buf, uint64(mj.MediaWidth), 10, mj.MediaWidth < 0)
	buf.WriteString(`,"media_height":`)
	fflib.FormatBits2(buf, uint64(mj.MediaHeight), 10, mj.MediaHeight < 0)
	buf.WriteString(`,"video_frames":`)
	fflib.FormatBits2(buf, uint64(mj.VideoFrames), 10, mj.VideoFrames < 0)
	buf.WriteString(`,"video_fps":`)
	fflib.FormatBits2(buf, uint64(mj.VideoFps), 10, mj.VideoFps < 0)
	buf.WriteString(`,"video_codec":`)
	fflib.WriteJsonString(buf, string(mj.VideoCodec))
	buf.WriteString(`,"video_bit_rate":`)
	fflib.FormatBits2(buf, uint64(mj.VideoBitRate), 10, mj.VideoBitRate < 0)
	buf.WriteString(`,"audio_codec":`)
	fflib.WriteJsonString(buf, string(mj.AudioCodec))
	buf.WriteString(`,"audio_bit_rate":`)
	fflib.FormatBits2(buf, uint64(mj.AudioBitRate), 10, mj.AudioBitRate < 0)
	buf.WriteString(`,"media_file_size":`)
	fflib.FormatBits2(buf, uint64(mj.MediaFileSize), 10, mj.MediaFileSize < 0)
	buf.WriteString(`,"media_type":`)
	fflib.WriteJsonString(buf, string(mj.MediaType))
	buf.WriteString(`,"media_signature":`)
	fflib.WriteJsonString(buf, string(mj.MediaSignature))
	buf.WriteString(`,"system_status":`)
	fflib.WriteJsonString(buf, string(mj.SystemStatus))
	buf.WriteString(`,"preview_url":`)
	fflib.WriteJsonString(buf, string(mj.PreviewURL))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MediaReadDatabase = iota
	ffj_t_MediaReadDatano_such_key

	ffj_t_MediaReadData_MediaDescription

	ffj_t_MediaReadData_MediaWidth

	ffj_t_MediaReadData_MediaHeight

	ffj_t_MediaReadData_VideoFrames

	ffj_t_MediaReadData_VideoFps

	ffj_t_MediaReadData_VideoCodec

	ffj_t_MediaReadData_VideoBitRate

	ffj_t_MediaReadData_AudioCodec

	ffj_t_MediaReadData_AudioBitRate

	ffj_t_MediaReadData_MediaFileSize

	ffj_t_MediaReadData_MediaType

	ffj_t_MediaReadData_MediaSignature

	ffj_t_MediaReadData_SystemStatus

	ffj_t_MediaReadData_PreviewURL
)

var ffj_key_MediaReadData_MediaDescription = []byte("media_description")

var ffj_key_MediaReadData_MediaWidth = []byte("media_width")

var ffj_key_MediaReadData_MediaHeight = []byte("media_height")

var ffj_key_MediaReadData_VideoFrames = []byte("video_frames")

var ffj_key_MediaReadData_VideoFps = []byte("video_fps")

var ffj_key_MediaReadData_VideoCodec = []byte("video_codec")

var ffj_key_MediaReadData_VideoBitRate = []byte("video_bit_rate")

var ffj_key_MediaReadData_AudioCodec = []byte("audio_codec")

var ffj_key_MediaReadData_AudioBitRate = []byte("audio_bit_rate")

var ffj_key_MediaReadData_MediaFileSize = []byte("media_file_size")

var ffj_key_MediaReadData_MediaType = []byte("media_type")

var ffj_key_MediaReadData_MediaSignature = []byte("media_signature")

var ffj_key_MediaReadData_SystemStatus = []byte("system_status")

var ffj_key_MediaReadData_PreviewURL = []byte("preview_url")

func (uj *MediaReadData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MediaReadData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MediaReadDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MediaReadDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_MediaReadData_AudioCodec, kn) {
						currentKey = ffj_t_MediaReadData_AudioCodec
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MediaReadData_AudioBitRate, kn) {
						currentKey = ffj_t_MediaReadData_AudioBitRate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_MediaReadData_MediaDescription, kn) {
						currentKey = ffj_t_MediaReadData_MediaDescription
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MediaReadData_MediaWidth, kn) {
						currentKey = ffj_t_MediaReadData_MediaWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MediaReadData_MediaHeight, kn) {
						currentKey = ffj_t_MediaReadData_MediaHeight
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MediaReadData_MediaFileSize, kn) {
						currentKey = ffj_t_MediaReadData_MediaFileSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MediaReadData_MediaType, kn) {
						currentKey = ffj_t_MediaReadData_MediaType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MediaReadData_MediaSignature, kn) {
						currentKey = ffj_t_MediaReadData_MediaSignature
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_MediaReadData_PreviewURL, kn) {
						currentKey = ffj_t_MediaReadData_PreviewURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_MediaReadData_SystemStatus, kn) {
						currentKey = ffj_t_MediaReadData_SystemStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_MediaReadData_VideoFrames, kn) {
						currentKey = ffj_t_MediaReadData_VideoFrames
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MediaReadData_VideoFps, kn) {
						currentKey = ffj_t_MediaReadData_VideoFps
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MediaReadData_VideoCodec, kn) {
						currentKey = ffj_t_MediaReadData_VideoCodec
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MediaReadData_VideoBitRate, kn) {
						currentKey = ffj_t_MediaReadData_VideoBitRate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_MediaReadData_PreviewURL, kn) {
					currentKey = ffj_t_MediaReadData_PreviewURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MediaReadData_SystemStatus, kn) {
					currentKey = ffj_t_MediaReadData_SystemStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MediaReadData_MediaSignature, kn) {
					currentKey = ffj_t_MediaReadData_MediaSignature
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MediaReadData_MediaType, kn) {
					currentKey = ffj_t_MediaReadData_MediaType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MediaReadData_MediaFileSize, kn) {
					currentKey = ffj_t_MediaReadData_MediaFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MediaReadData_AudioBitRate, kn) {
					currentKey = ffj_t_MediaReadData_AudioBitRate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MediaReadData_AudioCodec, kn) {
					currentKey = ffj_t_MediaReadData_AudioCodec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MediaReadData_VideoBitRate, kn) {
					currentKey = ffj_t_MediaReadData_VideoBitRate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MediaReadData_VideoCodec, kn) {
					currentKey = ffj_t_MediaReadData_VideoCodec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MediaReadData_VideoFps, kn) {
					currentKey = ffj_t_MediaReadData_VideoFps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MediaReadData_VideoFrames, kn) {
					currentKey = ffj_t_MediaReadData_VideoFrames
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MediaReadData_MediaHeight, kn) {
					currentKey = ffj_t_MediaReadData_MediaHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MediaReadData_MediaWidth, kn) {
					currentKey = ffj_t_MediaReadData_MediaWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MediaReadData_MediaDescription, kn) {
					currentKey = ffj_t_MediaReadData_MediaDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MediaReadDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MediaReadData_MediaDescription:
					goto handle_MediaDescription

				case ffj_t_MediaReadData_MediaWidth:
					goto handle_MediaWidth

				case ffj_t_MediaReadData_MediaHeight:
					goto handle_MediaHeight

				case ffj_t_MediaReadData_VideoFrames:
					goto handle_VideoFrames

				case ffj_t_MediaReadData_VideoFps:
					goto handle_VideoFps

				case ffj_t_MediaReadData_VideoCodec:
					goto handle_VideoCodec

				case ffj_t_MediaReadData_VideoBitRate:
					goto handle_VideoBitRate

				case ffj_t_MediaReadData_AudioCodec:
					goto handle_AudioCodec

				case ffj_t_MediaReadData_AudioBitRate:
					goto handle_AudioBitRate

				case ffj_t_MediaReadData_MediaFileSize:
					goto handle_MediaFileSize

				case ffj_t_MediaReadData_MediaType:
					goto handle_MediaType

				case ffj_t_MediaReadData_MediaSignature:
					goto handle_MediaSignature

				case ffj_t_MediaReadData_SystemStatus:
					goto handle_SystemStatus

				case ffj_t_MediaReadData_PreviewURL:
					goto handle_PreviewURL

				case ffj_t_MediaReadDatano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_MediaDescription:

	/* handler: uj.MediaDescription type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.MediaDescription = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MediaWidth:

	/* handler: uj.MediaWidth type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MediaWidth = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MediaHeight:

	/* handler: uj.MediaHeight type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MediaHeight = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoFrames:

	/* handler: uj.VideoFrames type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.VideoFrames = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoFps:

	/* handler: uj.VideoFps type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.VideoFps = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoCodec:

	/* handler: uj.VideoCodec type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.VideoCodec = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoBitRate:

	/* handler: uj.VideoBitRate type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.VideoBitRate = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AudioCodec:

	/* handler: uj.AudioCodec type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AudioCodec = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AudioBitRate:

	/* handler: uj.AudioBitRate type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.AudioBitRate = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MediaFileSize:

	/* handler: uj.MediaFileSize type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MediaFileSize = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MediaType:

	/* handler: uj.MediaType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.MediaType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MediaSignature:

	/* handler: uj.MediaSignature type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.MediaSignature = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SystemStatus:

	/* handler: uj.SystemStatus type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.SystemStatus = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PreviewURL:

	/* handler: uj.PreviewURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.PreviewURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *MediaReadResponse) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MediaReadResponse) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"code":`)
	fflib.FormatBits2(buf, uint64(mj.Code), 10, mj.Code < 0)
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(mj.Message))
	buf.WriteString(`,"data":`)

	{

		err = mj.Data.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MediaReadResponsebase = iota
	ffj_t_MediaReadResponseno_such_key

	ffj_t_MediaReadResponse_Code

	ffj_t_MediaReadResponse_Message

	ffj_t_MediaReadResponse_Data
)

var ffj_key_MediaReadResponse_Code = []byte("code")

var ffj_key_MediaReadResponse_Message = []byte("message")

var ffj_key_MediaReadResponse_Data = []byte("data")

func (uj *MediaReadResponse) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MediaReadResponse) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MediaReadResponsebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MediaReadResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_MediaReadResponse_Code, kn) {
						currentKey = ffj_t_MediaReadResponse_Code
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_MediaReadResponse_Data, kn) {
						currentKey = ffj_t_MediaReadResponse_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_MediaReadResponse_Message, kn) {
						currentKey = ffj_t_MediaReadResponse_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_MediaReadResponse_Data, kn) {
					currentKey = ffj_t_MediaReadResponse_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MediaReadResponse_Message, kn) {
					currentKey = ffj_t_MediaReadResponse_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MediaReadResponse_Code, kn) {
					currentKey = ffj_t_MediaReadResponse_Code
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MediaReadResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MediaReadResponse_Code:
					goto handle_Code

				case ffj_t_MediaReadResponse_Message:
					goto handle_Message

				case ffj_t_MediaReadResponse_Data:
					goto handle_Data

				case ffj_t_MediaReadResponseno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Code:

	/* handler: uj.Code type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Code = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=gdt.MediaReadData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Data.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *MediaSelectData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MediaSelectData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"list":`)
	if mj.List != nil {
		buf.WriteString(`[`)
		for i, v := range mj.List {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"page_info":`)

	{

		err = mj.PageInfo.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MediaSelectDatabase = iota
	ffj_t_MediaSelectDatano_such_key

	ffj_t_MediaSelectData_List

	ffj_t_MediaSelectData_PageInfo
)

var ffj_key_MediaSelectData_List = []byte("list")

var ffj_key_MediaSelectData_PageInfo = []byte("page_info")

func (uj *MediaSelectData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MediaSelectData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MediaSelectDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MediaSelectDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_MediaSelectData_List, kn) {
						currentKey = ffj_t_MediaSelectData_List
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_MediaSelectData_PageInfo, kn) {
						currentKey = ffj_t_MediaSelectData_PageInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_MediaSelectData_PageInfo, kn) {
					currentKey = ffj_t_MediaSelectData_PageInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MediaSelectData_List, kn) {
					currentKey = ffj_t_MediaSelectData_List
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MediaSelectDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MediaSelectData_List:
					goto handle_List

				case ffj_t_MediaSelectData_PageInfo:
					goto handle_PageInfo

				case ffj_t_MediaSelectDatano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_List:

	/* handler: uj.List type=[]gdt.MediaSelectDataList kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.List = nil
		} else {

			uj.List = []MediaSelectDataList{}

			wantVal := true

			for {

				var tmp_uj__List MediaSelectDataList

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__List type=gdt.MediaSelectDataList kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__List.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.List = append(uj.List, tmp_uj__List)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PageInfo:

	/* handler: uj.PageInfo type=gdt.PageInfoData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.PageInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *MediaSelectDataList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MediaSelectDataList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"media_id":`)
	fflib.FormatBits2(buf, uint64(mj.MediaID), 10, mj.MediaID < 0)
	buf.WriteString(`,"media_description":`)
	fflib.WriteJsonString(buf, string(mj.MediaDescription))
	buf.WriteString(`,"media_width":`)
	fflib.FormatBits2(buf, uint64(mj.MediaWidth), 10, mj.MediaWidth < 0)
	buf.WriteString(`,"media_height":`)
	fflib.FormatBits2(buf, uint64(mj.MediaHeight), 10, mj.MediaHeight < 0)
	buf.WriteString(`,"video_frames":`)
	fflib.FormatBits2(buf, uint64(mj.VideoFrames), 10, mj.VideoFrames < 0)
	buf.WriteString(`,"video_fps":`)
	fflib.FormatBits2(buf, uint64(mj.VideoFps), 10, mj.VideoFps < 0)
	buf.WriteString(`,"video_codec":`)
	fflib.WriteJsonString(buf, string(mj.VideoCodec))
	buf.WriteString(`,"video_bit_rate":`)
	fflib.FormatBits2(buf, uint64(mj.VideoBitRate), 10, mj.VideoBitRate < 0)
	buf.WriteString(`,"audio_codec":`)
	fflib.WriteJsonString(buf, string(mj.AudioCodec))
	buf.WriteString(`,"audio_bit_rate":`)
	fflib.FormatBits2(buf, uint64(mj.AudioBitRate), 10, mj.AudioBitRate < 0)
	buf.WriteString(`,"media_file_size":`)
	fflib.FormatBits2(buf, uint64(mj.MediaFileSize), 10, mj.MediaFileSize < 0)
	buf.WriteString(`,"media_type":`)
	fflib.WriteJsonString(buf, string(mj.MediaType))
	buf.WriteString(`,"media_signature":`)
	fflib.WriteJsonString(buf, string(mj.MediaSignature))
	buf.WriteString(`,"system_status":`)
	fflib.WriteJsonString(buf, string(mj.SystemStatus))
	buf.WriteString(`,"preview_url":`)
	fflib.WriteJsonString(buf, string(mj.PreviewURL))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MediaSelectDataListbase = iota
	ffj_t_MediaSelectDataListno_such_key

	ffj_t_MediaSelectDataList_MediaID

	ffj_t_MediaSelectDataList_MediaDescription

	ffj_t_MediaSelectDataList_MediaWidth

	ffj_t_MediaSelectDataList_MediaHeight

	ffj_t_MediaSelectDataList_VideoFrames

	ffj_t_MediaSelectDataList_VideoFps

	ffj_t_MediaSelectDataList_VideoCodec

	ffj_t_MediaSelectDataList_VideoBitRate

	ffj_t_MediaSelectDataList_AudioCodec

	ffj_t_MediaSelectDataList_AudioBitRate

	ffj_t_MediaSelectDataList_MediaFileSize

	ffj_t_MediaSelectDataList_MediaType

	ffj_t_MediaSelectDataList_MediaSignature

	ffj_t_MediaSelectDataList_SystemStatus

	ffj_t_MediaSelectDataList_PreviewURL
)

var ffj_key_MediaSelectDataList_MediaID = []byte("media_id")

var ffj_key_MediaSelectDataList_MediaDescription = []byte("media_description")

var ffj_key_MediaSelectDataList_MediaWidth = []byte("media_width")

var ffj_key_MediaSelectDataList_MediaHeight = []byte("media_height")

var ffj_key_MediaSelectDataList_VideoFrames = []byte("video_frames")

var ffj_key_MediaSelectDataList_VideoFps = []byte("video_fps")

var ffj_key_MediaSelectDataList_VideoCodec = []byte("video_codec")

var ffj_key_MediaSelectDataList_VideoBitRate = []byte("video_bit_rate")

var ffj_key_MediaSelectDataList_AudioCodec = []byte("audio_codec")

var ffj_key_MediaSelectDataList_AudioBitRate = []byte("audio_bit_rate")

var ffj_key_MediaSelectDataList_MediaFileSize = []byte("media_file_size")

var ffj_key_MediaSelectDataList_MediaType = []byte("media_type")

var ffj_key_MediaSelectDataList_MediaSignature = []byte("media_signature")

var ffj_key_MediaSelectDataList_SystemStatus = []byte("system_status")

var ffj_key_MediaSelectDataList_PreviewURL = []byte("preview_url")

func (uj *MediaSelectDataList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MediaSelectDataList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MediaSelectDataListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MediaSelectDataListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_MediaSelectDataList_AudioCodec, kn) {
						currentKey = ffj_t_MediaSelectDataList_AudioCodec
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MediaSelectDataList_AudioBitRate, kn) {
						currentKey = ffj_t_MediaSelectDataList_AudioBitRate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_MediaSelectDataList_MediaID, kn) {
						currentKey = ffj_t_MediaSelectDataList_MediaID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MediaSelectDataList_MediaDescription, kn) {
						currentKey = ffj_t_MediaSelectDataList_MediaDescription
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MediaSelectDataList_MediaWidth, kn) {
						currentKey = ffj_t_MediaSelectDataList_MediaWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MediaSelectDataList_MediaHeight, kn) {
						currentKey = ffj_t_MediaSelectDataList_MediaHeight
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MediaSelectDataList_MediaFileSize, kn) {
						currentKey = ffj_t_MediaSelectDataList_MediaFileSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MediaSelectDataList_MediaType, kn) {
						currentKey = ffj_t_MediaSelectDataList_MediaType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MediaSelectDataList_MediaSignature, kn) {
						currentKey = ffj_t_MediaSelectDataList_MediaSignature
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_MediaSelectDataList_PreviewURL, kn) {
						currentKey = ffj_t_MediaSelectDataList_PreviewURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_MediaSelectDataList_SystemStatus, kn) {
						currentKey = ffj_t_MediaSelectDataList_SystemStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_MediaSelectDataList_VideoFrames, kn) {
						currentKey = ffj_t_MediaSelectDataList_VideoFrames
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MediaSelectDataList_VideoFps, kn) {
						currentKey = ffj_t_MediaSelectDataList_VideoFps
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MediaSelectDataList_VideoCodec, kn) {
						currentKey = ffj_t_MediaSelectDataList_VideoCodec
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MediaSelectDataList_VideoBitRate, kn) {
						currentKey = ffj_t_MediaSelectDataList_VideoBitRate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_MediaSelectDataList_PreviewURL, kn) {
					currentKey = ffj_t_MediaSelectDataList_PreviewURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MediaSelectDataList_SystemStatus, kn) {
					currentKey = ffj_t_MediaSelectDataList_SystemStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MediaSelectDataList_MediaSignature, kn) {
					currentKey = ffj_t_MediaSelectDataList_MediaSignature
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MediaSelectDataList_MediaType, kn) {
					currentKey = ffj_t_MediaSelectDataList_MediaType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MediaSelectDataList_MediaFileSize, kn) {
					currentKey = ffj_t_MediaSelectDataList_MediaFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MediaSelectDataList_AudioBitRate, kn) {
					currentKey = ffj_t_MediaSelectDataList_AudioBitRate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MediaSelectDataList_AudioCodec, kn) {
					currentKey = ffj_t_MediaSelectDataList_AudioCodec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MediaSelectDataList_VideoBitRate, kn) {
					currentKey = ffj_t_MediaSelectDataList_VideoBitRate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MediaSelectDataList_VideoCodec, kn) {
					currentKey = ffj_t_MediaSelectDataList_VideoCodec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MediaSelectDataList_VideoFps, kn) {
					currentKey = ffj_t_MediaSelectDataList_VideoFps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MediaSelectDataList_VideoFrames, kn) {
					currentKey = ffj_t_MediaSelectDataList_VideoFrames
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MediaSelectDataList_MediaHeight, kn) {
					currentKey = ffj_t_MediaSelectDataList_MediaHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MediaSelectDataList_MediaWidth, kn) {
					currentKey = ffj_t_MediaSelectDataList_MediaWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MediaSelectDataList_MediaDescription, kn) {
					currentKey = ffj_t_MediaSelectDataList_MediaDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MediaSelectDataList_MediaID, kn) {
					currentKey = ffj_t_MediaSelectDataList_MediaID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MediaSelectDataListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MediaSelectDataList_MediaID:
					goto handle_MediaID

				case ffj_t_MediaSelectDataList_MediaDescription:
					goto handle_MediaDescription

				case ffj_t_MediaSelectDataList_MediaWidth:
					goto handle_MediaWidth

				case ffj_t_MediaSelectDataList_MediaHeight:
					goto handle_MediaHeight

				case ffj_t_MediaSelectDataList_VideoFrames:
					goto handle_VideoFrames

				case ffj_t_MediaSelectDataList_VideoFps:
					goto handle_VideoFps

				case ffj_t_MediaSelectDataList_VideoCodec:
					goto handle_VideoCodec

				case ffj_t_MediaSelectDataList_VideoBitRate:
					goto handle_VideoBitRate

				case ffj_t_MediaSelectDataList_AudioCodec:
					goto handle_AudioCodec

				case ffj_t_MediaSelectDataList_AudioBitRate:
					goto handle_AudioBitRate

				case ffj_t_MediaSelectDataList_MediaFileSize:
					goto handle_MediaFileSize

				case ffj_t_MediaSelectDataList_MediaType:
					goto handle_MediaType

				case ffj_t_MediaSelectDataList_MediaSignature:
					goto handle_MediaSignature

				case ffj_t_MediaSelectDataList_SystemStatus:
					goto handle_SystemStatus

				case ffj_t_MediaSelectDataList_PreviewURL:
					goto handle_PreviewURL

				case ffj_t_MediaSelectDataListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_MediaID:

	/* handler: uj.MediaID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MediaID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MediaDescription:

	/* handler: uj.MediaDescription type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.MediaDescription = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MediaWidth:

	/* handler: uj.MediaWidth type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MediaWidth = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MediaHeight:

	/* handler: uj.MediaHeight type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MediaHeight = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoFrames:

	/* handler: uj.VideoFrames type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.VideoFrames = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoFps:

	/* handler: uj.VideoFps type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.VideoFps = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoCodec:

	/* handler: uj.VideoCodec type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.VideoCodec = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoBitRate:

	/* handler: uj.VideoBitRate type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.VideoBitRate = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AudioCodec:

	/* handler: uj.AudioCodec type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AudioCodec = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AudioBitRate:

	/* handler: uj.AudioBitRate type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.AudioBitRate = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MediaFileSize:

	/* handler: uj.MediaFileSize type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MediaFileSize = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MediaType:

	/* handler: uj.MediaType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.MediaType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MediaSignature:

	/* handler: uj.MediaSignature type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.MediaSignature = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SystemStatus:

	/* handler: uj.SystemStatus type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.SystemStatus = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PreviewURL:

	/* handler: uj.PreviewURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.PreviewURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *MediaSelectResponse) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MediaSelectResponse) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"code":`)
	fflib.FormatBits2(buf, uint64(mj.Code), 10, mj.Code < 0)
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(mj.Message))
	buf.WriteString(`,"data":`)

	{

		err = mj.Data.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MediaSelectResponsebase = iota
	ffj_t_MediaSelectResponseno_such_key

	ffj_t_MediaSelectResponse_Code

	ffj_t_MediaSelectResponse_Message

	ffj_t_MediaSelectResponse_Data
)

var ffj_key_MediaSelectResponse_Code = []byte("code")

var ffj_key_MediaSelectResponse_Message = []byte("message")

var ffj_key_MediaSelectResponse_Data = []byte("data")

func (uj *MediaSelectResponse) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MediaSelectResponse) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MediaSelectResponsebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MediaSelectResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_MediaSelectResponse_Code, kn) {
						currentKey = ffj_t_MediaSelectResponse_Code
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_MediaSelectResponse_Data, kn) {
						currentKey = ffj_t_MediaSelectResponse_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_MediaSelectResponse_Message, kn) {
						currentKey = ffj_t_MediaSelectResponse_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_MediaSelectResponse_Data, kn) {
					currentKey = ffj_t_MediaSelectResponse_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MediaSelectResponse_Message, kn) {
					currentKey = ffj_t_MediaSelectResponse_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MediaSelectResponse_Code, kn) {
					currentKey = ffj_t_MediaSelectResponse_Code
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MediaSelectResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MediaSelectResponse_Code:
					goto handle_Code

				case ffj_t_MediaSelectResponse_Message:
					goto handle_Message

				case ffj_t_MediaSelectResponse_Data:
					goto handle_Data

				case ffj_t_MediaSelectResponseno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Code:

	/* handler: uj.Code type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Code = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=gdt.MediaSelectData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Data.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *PageInfoData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PageInfoData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"page":`)
	fflib.FormatBits2(buf, uint64(mj.Page), 10, mj.Page < 0)
	buf.WriteString(`,"page_size":`)
	fflib.FormatBits2(buf, uint64(mj.PageSize), 10, mj.PageSize < 0)
	buf.WriteString(`,"total_number":`)
	fflib.FormatBits2(buf, uint64(mj.TotalNum), 10, mj.TotalNum < 0)
	buf.WriteString(`,"total_page":`)
	fflib.FormatBits2(buf, uint64(mj.TotalPage), 10, mj.TotalPage < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PageInfoDatabase = iota
	ffj_t_PageInfoDatano_such_key

	ffj_t_PageInfoData_Page

	ffj_t_PageInfoData_PageSize

	ffj_t_PageInfoData_TotalNum

	ffj_t_PageInfoData_TotalPage
)

var ffj_key_PageInfoData_Page = []byte("page")

var ffj_key_PageInfoData_PageSize = []byte("page_size")

var ffj_key_PageInfoData_TotalNum = []byte("total_number")

var ffj_key_PageInfoData_TotalPage = []byte("total_page")

func (uj *PageInfoData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PageInfoData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PageInfoDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PageInfoDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_PageInfoData_Page, kn) {
						currentKey = ffj_t_PageInfoData_Page
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PageInfoData_PageSize, kn) {
						currentKey = ffj_t_PageInfoData_PageSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_PageInfoData_TotalNum, kn) {
						currentKey = ffj_t_PageInfoData_TotalNum
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PageInfoData_TotalPage, kn) {
						currentKey = ffj_t_PageInfoData_TotalPage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_PageInfoData_TotalPage, kn) {
					currentKey = ffj_t_PageInfoData_TotalPage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_PageInfoData_TotalNum, kn) {
					currentKey = ffj_t_PageInfoData_TotalNum
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PageInfoData_PageSize, kn) {
					currentKey = ffj_t_PageInfoData_PageSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PageInfoData_Page, kn) {
					currentKey = ffj_t_PageInfoData_Page
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PageInfoDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PageInfoData_Page:
					goto handle_Page

				case ffj_t_PageInfoData_PageSize:
					goto handle_PageSize

				case ffj_t_PageInfoData_TotalNum:
					goto handle_TotalNum

				case ffj_t_PageInfoData_TotalPage:
					goto handle_TotalPage

				case ffj_t_PageInfoDatano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Page:

	/* handler: uj.Page type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Page = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PageSize:

	/* handler: uj.PageSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.PageSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalNum:

	/* handler: uj.TotalNum type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.TotalNum = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalPage:

	/* handler: uj.TotalPage type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.TotalPage = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ProductInfoType) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ProductInfoType) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"product_type_apple_app_store":`)

	{

		err = mj.ProductTypeAppleAppStore.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"product_type_app_android_open_platform":`)

	{

		err = mj.ProductTypeAppAndroidOpenPlatform.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"product_type_union_app_info":`)

	{

		err = mj.ProductTypeUnionAppInfo.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ProductInfoTypebase = iota
	ffj_t_ProductInfoTypeno_such_key

	ffj_t_ProductInfoType_ProductTypeAppleAppStore

	ffj_t_ProductInfoType_ProductTypeAppAndroidOpenPlatform

	ffj_t_ProductInfoType_ProductTypeUnionAppInfo
)

var ffj_key_ProductInfoType_ProductTypeAppleAppStore = []byte("product_type_apple_app_store")

var ffj_key_ProductInfoType_ProductTypeAppAndroidOpenPlatform = []byte("product_type_app_android_open_platform")

var ffj_key_ProductInfoType_ProductTypeUnionAppInfo = []byte("product_type_union_app_info")

func (uj *ProductInfoType) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ProductInfoType) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ProductInfoTypebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ProductInfoTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_ProductInfoType_ProductTypeAppleAppStore, kn) {
						currentKey = ffj_t_ProductInfoType_ProductTypeAppleAppStore
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductInfoType_ProductTypeAppAndroidOpenPlatform, kn) {
						currentKey = ffj_t_ProductInfoType_ProductTypeAppAndroidOpenPlatform
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductInfoType_ProductTypeUnionAppInfo, kn) {
						currentKey = ffj_t_ProductInfoType_ProductTypeUnionAppInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_ProductInfoType_ProductTypeUnionAppInfo, kn) {
					currentKey = ffj_t_ProductInfoType_ProductTypeUnionAppInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ProductInfoType_ProductTypeAppAndroidOpenPlatform, kn) {
					currentKey = ffj_t_ProductInfoType_ProductTypeAppAndroidOpenPlatform
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ProductInfoType_ProductTypeAppleAppStore, kn) {
					currentKey = ffj_t_ProductInfoType_ProductTypeAppleAppStore
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ProductInfoTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ProductInfoType_ProductTypeAppleAppStore:
					goto handle_ProductTypeAppleAppStore

				case ffj_t_ProductInfoType_ProductTypeAppAndroidOpenPlatform:
					goto handle_ProductTypeAppAndroidOpenPlatform

				case ffj_t_ProductInfoType_ProductTypeUnionAppInfo:
					goto handle_ProductTypeUnionAppInfo

				case ffj_t_ProductInfoTypeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ProductTypeAppleAppStore:

	/* handler: uj.ProductTypeAppleAppStore type=gdt.ProductTypeAppleAppStoreType kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ProductTypeAppleAppStore.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProductTypeAppAndroidOpenPlatform:

	/* handler: uj.ProductTypeAppAndroidOpenPlatform type=gdt.ProductTypeAppAndroidOpenPlatformType kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ProductTypeAppAndroidOpenPlatform.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProductTypeUnionAppInfo:

	/* handler: uj.ProductTypeUnionAppInfo type=gdt.ProductTypeUnionAppInfoType kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ProductTypeUnionAppInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ProductTypeAppAndroidOpenPlatformType) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ProductTypeAppAndroidOpenPlatformType) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"app_property_packname":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyPackname))
	buf.WriteString(`,"app_property_version":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyVersion))
	buf.WriteString(`,"app_property_icon_url":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyIconUrl))
	buf.WriteString(`,"app_property_average_user_rating":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyAverageUserRating))
	buf.WriteString(`,"app_property_package_size_bytes":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyPackageSizeBytes))
	buf.WriteString(`,"app_property_genres":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyGenres))
	buf.WriteString(`,"app_property_pkg_url":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyPkgUrl))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ProductTypeAppAndroidOpenPlatformTypebase = iota
	ffj_t_ProductTypeAppAndroidOpenPlatformTypeno_such_key

	ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyPackname

	ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyVersion

	ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyIconUrl

	ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyAverageUserRating

	ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyPackageSizeBytes

	ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyGenres

	ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyPkgUrl
)

var ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyPackname = []byte("app_property_packname")

var ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyVersion = []byte("app_property_version")

var ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyIconUrl = []byte("app_property_icon_url")

var ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyAverageUserRating = []byte("app_property_average_user_rating")

var ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyPackageSizeBytes = []byte("app_property_package_size_bytes")

var ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyGenres = []byte("app_property_genres")

var ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyPkgUrl = []byte("app_property_pkg_url")

func (uj *ProductTypeAppAndroidOpenPlatformType) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ProductTypeAppAndroidOpenPlatformType) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ProductTypeAppAndroidOpenPlatformTypebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ProductTypeAppAndroidOpenPlatformTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyPackname, kn) {
						currentKey = ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyPackname
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyVersion, kn) {
						currentKey = ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyVersion
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyIconUrl, kn) {
						currentKey = ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyIconUrl
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyAverageUserRating, kn) {
						currentKey = ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyAverageUserRating
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyPackageSizeBytes, kn) {
						currentKey = ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyPackageSizeBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyGenres, kn) {
						currentKey = ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyGenres
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyPkgUrl, kn) {
						currentKey = ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyPkgUrl
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyPkgUrl, kn) {
					currentKey = ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyPkgUrl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyGenres, kn) {
					currentKey = ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyGenres
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyPackageSizeBytes, kn) {
					currentKey = ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyPackageSizeBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyAverageUserRating, kn) {
					currentKey = ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyAverageUserRating
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyIconUrl, kn) {
					currentKey = ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyIconUrl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyVersion, kn) {
					currentKey = ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ProductTypeAppAndroidOpenPlatformType_AppPropertyPackname, kn) {
					currentKey = ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyPackname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ProductTypeAppAndroidOpenPlatformTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyPackname:
					goto handle_AppPropertyPackname

				case ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyVersion:
					goto handle_AppPropertyVersion

				case ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyIconUrl:
					goto handle_AppPropertyIconUrl

				case ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyAverageUserRating:
					goto handle_AppPropertyAverageUserRating

				case ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyPackageSizeBytes:
					goto handle_AppPropertyPackageSizeBytes

				case ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyGenres:
					goto handle_AppPropertyGenres

				case ffj_t_ProductTypeAppAndroidOpenPlatformType_AppPropertyPkgUrl:
					goto handle_AppPropertyPkgUrl

				case ffj_t_ProductTypeAppAndroidOpenPlatformTypeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AppPropertyPackname:

	/* handler: uj.AppPropertyPackname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyPackname = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppPropertyVersion:

	/* handler: uj.AppPropertyVersion type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyVersion = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppPropertyIconUrl:

	/* handler: uj.AppPropertyIconUrl type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyIconUrl = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppPropertyAverageUserRating:

	/* handler: uj.AppPropertyAverageUserRating type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyAverageUserRating = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppPropertyPackageSizeBytes:

	/* handler: uj.AppPropertyPackageSizeBytes type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyPackageSizeBytes = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppPropertyGenres:

	/* handler: uj.AppPropertyGenres type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyGenres = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppPropertyPkgUrl:

	/* handler: uj.AppPropertyPkgUrl type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyPkgUrl = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ProductTypeAppleAppStoreType) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ProductTypeAppleAppStoreType) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"app_property_packname":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyPackname))
	buf.WriteString(`,"app_property_version":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyVersion))
	buf.WriteString(`,"app_property_icon_url":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyIconUrl))
	buf.WriteString(`,"app_property_icon_url_512":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyIconUrl512))
	buf.WriteString(`,"app_property_average_user_rating":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyAverageUserRating))
	buf.WriteString(`,"app_property_package_size_bytes":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyPackageSizeBytes))
	buf.WriteString(`,"app_property_genres":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyGenres))
	buf.WriteString(`,"app_property_pkg_url":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyPkgUrl))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ProductTypeAppleAppStoreTypebase = iota
	ffj_t_ProductTypeAppleAppStoreTypeno_such_key

	ffj_t_ProductTypeAppleAppStoreType_AppPropertyPackname

	ffj_t_ProductTypeAppleAppStoreType_AppPropertyVersion

	ffj_t_ProductTypeAppleAppStoreType_AppPropertyIconUrl

	ffj_t_ProductTypeAppleAppStoreType_AppPropertyIconUrl512

	ffj_t_ProductTypeAppleAppStoreType_AppPropertyAverageUserRating

	ffj_t_ProductTypeAppleAppStoreType_AppPropertyPackageSizeBytes

	ffj_t_ProductTypeAppleAppStoreType_AppPropertyGenres

	ffj_t_ProductTypeAppleAppStoreType_AppPropertyPkgUrl
)

var ffj_key_ProductTypeAppleAppStoreType_AppPropertyPackname = []byte("app_property_packname")

var ffj_key_ProductTypeAppleAppStoreType_AppPropertyVersion = []byte("app_property_version")

var ffj_key_ProductTypeAppleAppStoreType_AppPropertyIconUrl = []byte("app_property_icon_url")

var ffj_key_ProductTypeAppleAppStoreType_AppPropertyIconUrl512 = []byte("app_property_icon_url_512")

var ffj_key_ProductTypeAppleAppStoreType_AppPropertyAverageUserRating = []byte("app_property_average_user_rating")

var ffj_key_ProductTypeAppleAppStoreType_AppPropertyPackageSizeBytes = []byte("app_property_package_size_bytes")

var ffj_key_ProductTypeAppleAppStoreType_AppPropertyGenres = []byte("app_property_genres")

var ffj_key_ProductTypeAppleAppStoreType_AppPropertyPkgUrl = []byte("app_property_pkg_url")

func (uj *ProductTypeAppleAppStoreType) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ProductTypeAppleAppStoreType) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ProductTypeAppleAppStoreTypebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ProductTypeAppleAppStoreTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ProductTypeAppleAppStoreType_AppPropertyPackname, kn) {
						currentKey = ffj_t_ProductTypeAppleAppStoreType_AppPropertyPackname
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductTypeAppleAppStoreType_AppPropertyVersion, kn) {
						currentKey = ffj_t_ProductTypeAppleAppStoreType_AppPropertyVersion
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductTypeAppleAppStoreType_AppPropertyIconUrl, kn) {
						currentKey = ffj_t_ProductTypeAppleAppStoreType_AppPropertyIconUrl
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductTypeAppleAppStoreType_AppPropertyIconUrl512, kn) {
						currentKey = ffj_t_ProductTypeAppleAppStoreType_AppPropertyIconUrl512
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductTypeAppleAppStoreType_AppPropertyAverageUserRating, kn) {
						currentKey = ffj_t_ProductTypeAppleAppStoreType_AppPropertyAverageUserRating
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductTypeAppleAppStoreType_AppPropertyPackageSizeBytes, kn) {
						currentKey = ffj_t_ProductTypeAppleAppStoreType_AppPropertyPackageSizeBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductTypeAppleAppStoreType_AppPropertyGenres, kn) {
						currentKey = ffj_t_ProductTypeAppleAppStoreType_AppPropertyGenres
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductTypeAppleAppStoreType_AppPropertyPkgUrl, kn) {
						currentKey = ffj_t_ProductTypeAppleAppStoreType_AppPropertyPkgUrl
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ProductTypeAppleAppStoreType_AppPropertyPkgUrl, kn) {
					currentKey = ffj_t_ProductTypeAppleAppStoreType_AppPropertyPkgUrl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ProductTypeAppleAppStoreType_AppPropertyGenres, kn) {
					currentKey = ffj_t_ProductTypeAppleAppStoreType_AppPropertyGenres
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ProductTypeAppleAppStoreType_AppPropertyPackageSizeBytes, kn) {
					currentKey = ffj_t_ProductTypeAppleAppStoreType_AppPropertyPackageSizeBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ProductTypeAppleAppStoreType_AppPropertyAverageUserRating, kn) {
					currentKey = ffj_t_ProductTypeAppleAppStoreType_AppPropertyAverageUserRating
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ProductTypeAppleAppStoreType_AppPropertyIconUrl512, kn) {
					currentKey = ffj_t_ProductTypeAppleAppStoreType_AppPropertyIconUrl512
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ProductTypeAppleAppStoreType_AppPropertyIconUrl, kn) {
					currentKey = ffj_t_ProductTypeAppleAppStoreType_AppPropertyIconUrl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ProductTypeAppleAppStoreType_AppPropertyVersion, kn) {
					currentKey = ffj_t_ProductTypeAppleAppStoreType_AppPropertyVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ProductTypeAppleAppStoreType_AppPropertyPackname, kn) {
					currentKey = ffj_t_ProductTypeAppleAppStoreType_AppPropertyPackname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ProductTypeAppleAppStoreTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ProductTypeAppleAppStoreType_AppPropertyPackname:
					goto handle_AppPropertyPackname

				case ffj_t_ProductTypeAppleAppStoreType_AppPropertyVersion:
					goto handle_AppPropertyVersion

				case ffj_t_ProductTypeAppleAppStoreType_AppPropertyIconUrl:
					goto handle_AppPropertyIconUrl

				case ffj_t_ProductTypeAppleAppStoreType_AppPropertyIconUrl512:
					goto handle_AppPropertyIconUrl512

				case ffj_t_ProductTypeAppleAppStoreType_AppPropertyAverageUserRating:
					goto handle_AppPropertyAverageUserRating

				case ffj_t_ProductTypeAppleAppStoreType_AppPropertyPackageSizeBytes:
					goto handle_AppPropertyPackageSizeBytes

				case ffj_t_ProductTypeAppleAppStoreType_AppPropertyGenres:
					goto handle_AppPropertyGenres

				case ffj_t_ProductTypeAppleAppStoreType_AppPropertyPkgUrl:
					goto handle_AppPropertyPkgUrl

				case ffj_t_ProductTypeAppleAppStoreTypeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AppPropertyPackname:

	/* handler: uj.AppPropertyPackname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyPackname = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppPropertyVersion:

	/* handler: uj.AppPropertyVersion type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyVersion = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppPropertyIconUrl:

	/* handler: uj.AppPropertyIconUrl type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyIconUrl = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppPropertyIconUrl512:

	/* handler: uj.AppPropertyIconUrl512 type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyIconUrl512 = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppPropertyAverageUserRating:

	/* handler: uj.AppPropertyAverageUserRating type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyAverageUserRating = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppPropertyPackageSizeBytes:

	/* handler: uj.AppPropertyPackageSizeBytes type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyPackageSizeBytes = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppPropertyGenres:

	/* handler: uj.AppPropertyGenres type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyGenres = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppPropertyPkgUrl:

	/* handler: uj.AppPropertyPkgUrl type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyPkgUrl = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ProductTypeUnionAppInfoType) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ProductTypeUnionAppInfoType) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"app_property_packname":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyPackname))
	buf.WriteString(`,"app_property_version":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyVersion))
	buf.WriteString(`,"app_property_icon_url":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyIconUrl))
	buf.WriteString(`,"app_property_package_size_bytes":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyPackageSizeBytes))
	buf.WriteString(`,"app_property_pkg_md5":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyPkgMd5))
	buf.WriteString(`,"app_property_pkg_url":`)
	fflib.WriteJsonString(buf, string(mj.AppPropertyPkgUrl))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ProductTypeUnionAppInfoTypebase = iota
	ffj_t_ProductTypeUnionAppInfoTypeno_such_key

	ffj_t_ProductTypeUnionAppInfoType_AppPropertyPackname

	ffj_t_ProductTypeUnionAppInfoType_AppPropertyVersion

	ffj_t_ProductTypeUnionAppInfoType_AppPropertyIconUrl

	ffj_t_ProductTypeUnionAppInfoType_AppPropertyPackageSizeBytes

	ffj_t_ProductTypeUnionAppInfoType_AppPropertyPkgMd5

	ffj_t_ProductTypeUnionAppInfoType_AppPropertyPkgUrl
)

var ffj_key_ProductTypeUnionAppInfoType_AppPropertyPackname = []byte("app_property_packname")

var ffj_key_ProductTypeUnionAppInfoType_AppPropertyVersion = []byte("app_property_version")

var ffj_key_ProductTypeUnionAppInfoType_AppPropertyIconUrl = []byte("app_property_icon_url")

var ffj_key_ProductTypeUnionAppInfoType_AppPropertyPackageSizeBytes = []byte("app_property_package_size_bytes")

var ffj_key_ProductTypeUnionAppInfoType_AppPropertyPkgMd5 = []byte("app_property_pkg_md5")

var ffj_key_ProductTypeUnionAppInfoType_AppPropertyPkgUrl = []byte("app_property_pkg_url")

func (uj *ProductTypeUnionAppInfoType) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ProductTypeUnionAppInfoType) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ProductTypeUnionAppInfoTypebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ProductTypeUnionAppInfoTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ProductTypeUnionAppInfoType_AppPropertyPackname, kn) {
						currentKey = ffj_t_ProductTypeUnionAppInfoType_AppPropertyPackname
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductTypeUnionAppInfoType_AppPropertyVersion, kn) {
						currentKey = ffj_t_ProductTypeUnionAppInfoType_AppPropertyVersion
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductTypeUnionAppInfoType_AppPropertyIconUrl, kn) {
						currentKey = ffj_t_ProductTypeUnionAppInfoType_AppPropertyIconUrl
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductTypeUnionAppInfoType_AppPropertyPackageSizeBytes, kn) {
						currentKey = ffj_t_ProductTypeUnionAppInfoType_AppPropertyPackageSizeBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductTypeUnionAppInfoType_AppPropertyPkgMd5, kn) {
						currentKey = ffj_t_ProductTypeUnionAppInfoType_AppPropertyPkgMd5
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductTypeUnionAppInfoType_AppPropertyPkgUrl, kn) {
						currentKey = ffj_t_ProductTypeUnionAppInfoType_AppPropertyPkgUrl
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ProductTypeUnionAppInfoType_AppPropertyPkgUrl, kn) {
					currentKey = ffj_t_ProductTypeUnionAppInfoType_AppPropertyPkgUrl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ProductTypeUnionAppInfoType_AppPropertyPkgMd5, kn) {
					currentKey = ffj_t_ProductTypeUnionAppInfoType_AppPropertyPkgMd5
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ProductTypeUnionAppInfoType_AppPropertyPackageSizeBytes, kn) {
					currentKey = ffj_t_ProductTypeUnionAppInfoType_AppPropertyPackageSizeBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ProductTypeUnionAppInfoType_AppPropertyIconUrl, kn) {
					currentKey = ffj_t_ProductTypeUnionAppInfoType_AppPropertyIconUrl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ProductTypeUnionAppInfoType_AppPropertyVersion, kn) {
					currentKey = ffj_t_ProductTypeUnionAppInfoType_AppPropertyVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ProductTypeUnionAppInfoType_AppPropertyPackname, kn) {
					currentKey = ffj_t_ProductTypeUnionAppInfoType_AppPropertyPackname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ProductTypeUnionAppInfoTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ProductTypeUnionAppInfoType_AppPropertyPackname:
					goto handle_AppPropertyPackname

				case ffj_t_ProductTypeUnionAppInfoType_AppPropertyVersion:
					goto handle_AppPropertyVersion

				case ffj_t_ProductTypeUnionAppInfoType_AppPropertyIconUrl:
					goto handle_AppPropertyIconUrl

				case ffj_t_ProductTypeUnionAppInfoType_AppPropertyPackageSizeBytes:
					goto handle_AppPropertyPackageSizeBytes

				case ffj_t_ProductTypeUnionAppInfoType_AppPropertyPkgMd5:
					goto handle_AppPropertyPkgMd5

				case ffj_t_ProductTypeUnionAppInfoType_AppPropertyPkgUrl:
					goto handle_AppPropertyPkgUrl

				case ffj_t_ProductTypeUnionAppInfoTypeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AppPropertyPackname:

	/* handler: uj.AppPropertyPackname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyPackname = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppPropertyVersion:

	/* handler: uj.AppPropertyVersion type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyVersion = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppPropertyIconUrl:

	/* handler: uj.AppPropertyIconUrl type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyIconUrl = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppPropertyPackageSizeBytes:

	/* handler: uj.AppPropertyPackageSizeBytes type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyPackageSizeBytes = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppPropertyPkgMd5:

	/* handler: uj.AppPropertyPkgMd5 type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyPkgMd5 = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppPropertyPkgUrl:

	/* handler: uj.AppPropertyPkgUrl type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AppPropertyPkgUrl = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ProductsGetData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ProductsGetData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"list":`)
	if mj.List != nil {
		buf.WriteString(`[`)
		for i, v := range mj.List {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"page_info":`)

	{

		err = mj.PageInfo.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ProductsGetDatabase = iota
	ffj_t_ProductsGetDatano_such_key

	ffj_t_ProductsGetData_List

	ffj_t_ProductsGetData_PageInfo
)

var ffj_key_ProductsGetData_List = []byte("list")

var ffj_key_ProductsGetData_PageInfo = []byte("page_info")

func (uj *ProductsGetData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ProductsGetData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ProductsGetDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ProductsGetDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_ProductsGetData_List, kn) {
						currentKey = ffj_t_ProductsGetData_List
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_ProductsGetData_PageInfo, kn) {
						currentKey = ffj_t_ProductsGetData_PageInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_ProductsGetData_PageInfo, kn) {
					currentKey = ffj_t_ProductsGetData_PageInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ProductsGetData_List, kn) {
					currentKey = ffj_t_ProductsGetData_List
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ProductsGetDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ProductsGetData_List:
					goto handle_List

				case ffj_t_ProductsGetData_PageInfo:
					goto handle_PageInfo

				case ffj_t_ProductsGetDatano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_List:

	/* handler: uj.List type=[]gdt.ProductsGetDataList kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.List = nil
		} else {

			uj.List = []ProductsGetDataList{}

			wantVal := true

			for {

				var tmp_uj__List ProductsGetDataList

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__List type=gdt.ProductsGetDataList kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__List.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.List = append(uj.List, tmp_uj__List)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PageInfo:

	/* handler: uj.PageInfo type=gdt.PageInfoData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.PageInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ProductsGetDataList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ProductsGetDataList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"product_refs_id":`)
	fflib.WriteJsonString(buf, string(mj.ProductRefsID))
	buf.WriteString(`,"product_name":`)
	fflib.WriteJsonString(buf, string(mj.ProductName))
	buf.WriteString(`,"product_type":`)
	fflib.WriteJsonString(buf, string(mj.ProductType))
	buf.WriteString(`,"product_info":`)

	{

		err = mj.ProductInfo.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"subordinate_product_list":`)
	if mj.SubordinateProductList != nil {
		buf.WriteString(`[`)
		for i, v := range mj.SubordinateProductList {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"created_time":`)
	fflib.FormatBits2(buf, uint64(mj.CreatedTime), 10, mj.CreatedTime < 0)
	buf.WriteString(`,"last_modified_time":`)
	fflib.FormatBits2(buf, uint64(mj.LastModifiedTime), 10, mj.LastModifiedTime < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ProductsGetDataListbase = iota
	ffj_t_ProductsGetDataListno_such_key

	ffj_t_ProductsGetDataList_ProductRefsID

	ffj_t_ProductsGetDataList_ProductName

	ffj_t_ProductsGetDataList_ProductType

	ffj_t_ProductsGetDataList_ProductInfo

	ffj_t_ProductsGetDataList_SubordinateProductList

	ffj_t_ProductsGetDataList_CreatedTime

	ffj_t_ProductsGetDataList_LastModifiedTime
)

var ffj_key_ProductsGetDataList_ProductRefsID = []byte("product_refs_id")

var ffj_key_ProductsGetDataList_ProductName = []byte("product_name")

var ffj_key_ProductsGetDataList_ProductType = []byte("product_type")

var ffj_key_ProductsGetDataList_ProductInfo = []byte("product_info")

var ffj_key_ProductsGetDataList_SubordinateProductList = []byte("subordinate_product_list")

var ffj_key_ProductsGetDataList_CreatedTime = []byte("created_time")

var ffj_key_ProductsGetDataList_LastModifiedTime = []byte("last_modified_time")

func (uj *ProductsGetDataList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ProductsGetDataList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ProductsGetDataListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ProductsGetDataListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ProductsGetDataList_CreatedTime, kn) {
						currentKey = ffj_t_ProductsGetDataList_CreatedTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_ProductsGetDataList_LastModifiedTime, kn) {
						currentKey = ffj_t_ProductsGetDataList_LastModifiedTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_ProductsGetDataList_ProductRefsID, kn) {
						currentKey = ffj_t_ProductsGetDataList_ProductRefsID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductsGetDataList_ProductName, kn) {
						currentKey = ffj_t_ProductsGetDataList_ProductName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductsGetDataList_ProductType, kn) {
						currentKey = ffj_t_ProductsGetDataList_ProductType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProductsGetDataList_ProductInfo, kn) {
						currentKey = ffj_t_ProductsGetDataList_ProductInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ProductsGetDataList_SubordinateProductList, kn) {
						currentKey = ffj_t_ProductsGetDataList_SubordinateProductList
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ProductsGetDataList_LastModifiedTime, kn) {
					currentKey = ffj_t_ProductsGetDataList_LastModifiedTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ProductsGetDataList_CreatedTime, kn) {
					currentKey = ffj_t_ProductsGetDataList_CreatedTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ProductsGetDataList_SubordinateProductList, kn) {
					currentKey = ffj_t_ProductsGetDataList_SubordinateProductList
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ProductsGetDataList_ProductInfo, kn) {
					currentKey = ffj_t_ProductsGetDataList_ProductInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ProductsGetDataList_ProductType, kn) {
					currentKey = ffj_t_ProductsGetDataList_ProductType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ProductsGetDataList_ProductName, kn) {
					currentKey = ffj_t_ProductsGetDataList_ProductName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ProductsGetDataList_ProductRefsID, kn) {
					currentKey = ffj_t_ProductsGetDataList_ProductRefsID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ProductsGetDataListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ProductsGetDataList_ProductRefsID:
					goto handle_ProductRefsID

				case ffj_t_ProductsGetDataList_ProductName:
					goto handle_ProductName

				case ffj_t_ProductsGetDataList_ProductType:
					goto handle_ProductType

				case ffj_t_ProductsGetDataList_ProductInfo:
					goto handle_ProductInfo

				case ffj_t_ProductsGetDataList_SubordinateProductList:
					goto handle_SubordinateProductList

				case ffj_t_ProductsGetDataList_CreatedTime:
					goto handle_CreatedTime

				case ffj_t_ProductsGetDataList_LastModifiedTime:
					goto handle_LastModifiedTime

				case ffj_t_ProductsGetDataListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ProductRefsID:

	/* handler: uj.ProductRefsID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ProductRefsID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProductName:

	/* handler: uj.ProductName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ProductName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProductType:

	/* handler: uj.ProductType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ProductType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProductInfo:

	/* handler: uj.ProductInfo type=gdt.ProductInfoType kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ProductInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SubordinateProductList:

	/* handler: uj.SubordinateProductList type=[]gdt.SubordinateProduct kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.SubordinateProductList = nil
		} else {

			uj.SubordinateProductList = []SubordinateProduct{}

			wantVal := true

			for {

				var tmp_uj__SubordinateProductList SubordinateProduct

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__SubordinateProductList type=gdt.SubordinateProduct kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__SubordinateProductList.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.SubordinateProductList = append(uj.SubordinateProductList, tmp_uj__SubordinateProductList)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CreatedTime:

	/* handler: uj.CreatedTime type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.CreatedTime = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastModifiedTime:

	/* handler: uj.LastModifiedTime type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.LastModifiedTime = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ProductsGetResponse) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ProductsGetResponse) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"code":`)
	fflib.FormatBits2(buf, uint64(mj.Code), 10, mj.Code < 0)
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(mj.Message))
	buf.WriteString(`,"data":`)

	{

		err = mj.Data.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ProductsGetResponsebase = iota
	ffj_t_ProductsGetResponseno_such_key

	ffj_t_ProductsGetResponse_Code

	ffj_t_ProductsGetResponse_Message

	ffj_t_ProductsGetResponse_Data
)

var ffj_key_ProductsGetResponse_Code = []byte("code")

var ffj_key_ProductsGetResponse_Message = []byte("message")

var ffj_key_ProductsGetResponse_Data = []byte("data")

func (uj *ProductsGetResponse) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ProductsGetResponse) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ProductsGetResponsebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ProductsGetResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ProductsGetResponse_Code, kn) {
						currentKey = ffj_t_ProductsGetResponse_Code
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_ProductsGetResponse_Data, kn) {
						currentKey = ffj_t_ProductsGetResponse_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ProductsGetResponse_Message, kn) {
						currentKey = ffj_t_ProductsGetResponse_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ProductsGetResponse_Data, kn) {
					currentKey = ffj_t_ProductsGetResponse_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ProductsGetResponse_Message, kn) {
					currentKey = ffj_t_ProductsGetResponse_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ProductsGetResponse_Code, kn) {
					currentKey = ffj_t_ProductsGetResponse_Code
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ProductsGetResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ProductsGetResponse_Code:
					goto handle_Code

				case ffj_t_ProductsGetResponse_Message:
					goto handle_Message

				case ffj_t_ProductsGetResponse_Data:
					goto handle_Data

				case ffj_t_ProductsGetResponseno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Code:

	/* handler: uj.Code type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Code = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=gdt.ProductsGetData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Data.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *RequestData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *RequestData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"service_id":`)
	fflib.FormatBits2(buf, uint64(mj.ServiceID), 10, mj.ServiceID < 0)
	buf.WriteString(`,"params":`)
	fflib.WriteJsonString(buf, string(mj.Params))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_RequestDatabase = iota
	ffj_t_RequestDatano_such_key

	ffj_t_RequestData_ServiceID

	ffj_t_RequestData_Params
)

var ffj_key_RequestData_ServiceID = []byte("service_id")

var ffj_key_RequestData_Params = []byte("params")

func (uj *RequestData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *RequestData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_RequestDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_RequestDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_RequestData_Params, kn) {
						currentKey = ffj_t_RequestData_Params
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_RequestData_ServiceID, kn) {
						currentKey = ffj_t_RequestData_ServiceID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_RequestData_Params, kn) {
					currentKey = ffj_t_RequestData_Params
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_RequestData_ServiceID, kn) {
					currentKey = ffj_t_RequestData_ServiceID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_RequestDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_RequestData_ServiceID:
					goto handle_ServiceID

				case ffj_t_RequestData_Params:
					goto handle_Params

				case ffj_t_RequestDatano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ServiceID:

	/* handler: uj.ServiceID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ServiceID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Params:

	/* handler: uj.Params type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Params = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *SubordinateProduct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *SubordinateProduct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"sub_product_refs_id":`)
	fflib.WriteJsonString(buf, string(mj.SubProductRefsID))
	buf.WriteString(`,"package_name":`)
	fflib.WriteJsonString(buf, string(mj.PackageName))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_SubordinateProductbase = iota
	ffj_t_SubordinateProductno_such_key

	ffj_t_SubordinateProduct_SubProductRefsID

	ffj_t_SubordinateProduct_PackageName
)

var ffj_key_SubordinateProduct_SubProductRefsID = []byte("sub_product_refs_id")

var ffj_key_SubordinateProduct_PackageName = []byte("package_name")

func (uj *SubordinateProduct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *SubordinateProduct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_SubordinateProductbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_SubordinateProductno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_SubordinateProduct_PackageName, kn) {
						currentKey = ffj_t_SubordinateProduct_PackageName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_SubordinateProduct_SubProductRefsID, kn) {
						currentKey = ffj_t_SubordinateProduct_SubProductRefsID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_SubordinateProduct_PackageName, kn) {
					currentKey = ffj_t_SubordinateProduct_PackageName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_SubordinateProduct_SubProductRefsID, kn) {
					currentKey = ffj_t_SubordinateProduct_SubProductRefsID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_SubordinateProductno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_SubordinateProduct_SubProductRefsID:
					goto handle_SubProductRefsID

				case ffj_t_SubordinateProduct_PackageName:
					goto handle_PackageName

				case ffj_t_SubordinateProductno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_SubProductRefsID:

	/* handler: uj.SubProductRefsID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.SubProductRefsID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PackageName:

	/* handler: uj.PackageName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.PackageName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *TargetingType) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *TargetingType) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"age":`)
	if mj.Age != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Age {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"gender":`)
	if mj.Gender != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Gender {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"education":`)
	if mj.Education != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Education {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"relationship_status":`)
	if mj.RelationshipStatus != nil {
		buf.WriteString(`[`)
		for i, v := range mj.RelationshipStatus {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"living_status":`)
	if mj.LivingStatus != nil {
		buf.WriteString(`[`)
		for i, v := range mj.LivingStatus {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"business_interest":`)
	if mj.BusinessInterest != nil {
		buf.WriteString(`[`)
		for i, v := range mj.BusinessInterest {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.FormatBits2(buf, uint64(v), 10, v < 0)
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"keyword":`)

	{

		err = mj.Keyword.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"geo_location":`)

	{

		err = mj.GeoLocation.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"user_os":`)
	if mj.UserOS != nil {
		buf.WriteString(`[`)
		for i, v := range mj.UserOS {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"new_device":`)
	if mj.NewDevice != nil {
		buf.WriteString(`[`)
		for i, v := range mj.NewDevice {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"device_price":`)
	if mj.DevicePrice != nil {
		buf.WriteString(`[`)
		for i, v := range mj.DevicePrice {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"network_type":`)
	if mj.NetworkType != nil {
		buf.WriteString(`[`)
		for i, v := range mj.NetworkType {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"network_operator":`)
	if mj.NetworkOperator != nil {
		buf.WriteString(`[`)
		for i, v := range mj.NetworkOperator {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"dressing_index":`)
	if mj.DressingIndex != nil {
		buf.WriteString(`[`)
		for i, v := range mj.DressingIndex {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"uv_index":`)
	if mj.UVIndex != nil {
		buf.WriteString(`[`)
		for i, v := range mj.UVIndex {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"makeup_index":`)
	if mj.MakeupIndex != nil {
		buf.WriteString(`[`)
		for i, v := range mj.MakeupIndex {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"climate":`)
	if mj.Climate != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Climate {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"temperature":`)
	if mj.Temperature != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Temperature {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"app_install_status":`)
	if mj.AppInstallStatus != nil {
		buf.WriteString(`[`)
		for i, v := range mj.AppInstallStatus {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"app_behavior":`)
	if mj.AppBehavior != nil {
		buf.WriteString(`[`)
		for i, v := range mj.AppBehavior {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"shopping_capability":`)
	if mj.ShoppingCapability != nil {
		buf.WriteString(`[`)
		for i, v := range mj.ShoppingCapability {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"player_consupt":`)
	if mj.PlayerConsupt != nil {
		buf.WriteString(`[`)
		for i, v := range mj.PlayerConsupt {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"paying_user_type":`)
	if mj.PayingUserType != nil {
		buf.WriteString(`[`)
		for i, v := range mj.PayingUserType {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"residential_community_price":`)
	if mj.ResidentialCommunityPrice != nil {
		buf.WriteString(`[`)
		for i, v := range mj.ResidentialCommunityPrice {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"custom_audiences":`)
	if mj.CustomAudiences != nil {
		buf.WriteString(`[`)
		for i, v := range mj.CustomAudiences {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"excluded_custom_audiences":`)
	if mj.ExcludedCustomAudiences != nil {
		buf.WriteString(`[`)
		for i, v := range mj.ExcludedCustomAudiences {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_TargetingTypebase = iota
	ffj_t_TargetingTypeno_such_key

	ffj_t_TargetingType_Age

	ffj_t_TargetingType_Gender

	ffj_t_TargetingType_Education

	ffj_t_TargetingType_RelationshipStatus

	ffj_t_TargetingType_LivingStatus

	ffj_t_TargetingType_BusinessInterest

	ffj_t_TargetingType_Keyword

	ffj_t_TargetingType_GeoLocation

	ffj_t_TargetingType_UserOS

	ffj_t_TargetingType_NewDevice

	ffj_t_TargetingType_DevicePrice

	ffj_t_TargetingType_NetworkType

	ffj_t_TargetingType_NetworkOperator

	ffj_t_TargetingType_DressingIndex

	ffj_t_TargetingType_UVIndex

	ffj_t_TargetingType_MakeupIndex

	ffj_t_TargetingType_Climate

	ffj_t_TargetingType_Temperature

	ffj_t_TargetingType_AppInstallStatus

	ffj_t_TargetingType_AppBehavior

	ffj_t_TargetingType_ShoppingCapability

	ffj_t_TargetingType_PlayerConsupt

	ffj_t_TargetingType_PayingUserType

	ffj_t_TargetingType_ResidentialCommunityPrice

	ffj_t_TargetingType_CustomAudiences

	ffj_t_TargetingType_ExcludedCustomAudiences
)

var ffj_key_TargetingType_Age = []byte("age")

var ffj_key_TargetingType_Gender = []byte("gender")

var ffj_key_TargetingType_Education = []byte("education")

var ffj_key_TargetingType_RelationshipStatus = []byte("relationship_status")

var ffj_key_TargetingType_LivingStatus = []byte("living_status")

var ffj_key_TargetingType_BusinessInterest = []byte("business_interest")

var ffj_key_TargetingType_Keyword = []byte("keyword")

var ffj_key_TargetingType_GeoLocation = []byte("geo_location")

var ffj_key_TargetingType_UserOS = []byte("user_os")

var ffj_key_TargetingType_NewDevice = []byte("new_device")

var ffj_key_TargetingType_DevicePrice = []byte("device_price")

var ffj_key_TargetingType_NetworkType = []byte("network_type")

var ffj_key_TargetingType_NetworkOperator = []byte("network_operator")

var ffj_key_TargetingType_DressingIndex = []byte("dressing_index")

var ffj_key_TargetingType_UVIndex = []byte("uv_index")

var ffj_key_TargetingType_MakeupIndex = []byte("makeup_index")

var ffj_key_TargetingType_Climate = []byte("climate")

var ffj_key_TargetingType_Temperature = []byte("temperature")

var ffj_key_TargetingType_AppInstallStatus = []byte("app_install_status")

var ffj_key_TargetingType_AppBehavior = []byte("app_behavior")

var ffj_key_TargetingType_ShoppingCapability = []byte("shopping_capability")

var ffj_key_TargetingType_PlayerConsupt = []byte("player_consupt")

var ffj_key_TargetingType_PayingUserType = []byte("paying_user_type")

var ffj_key_TargetingType_ResidentialCommunityPrice = []byte("residential_community_price")

var ffj_key_TargetingType_CustomAudiences = []byte("custom_audiences")

var ffj_key_TargetingType_ExcludedCustomAudiences = []byte("excluded_custom_audiences")

func (uj *TargetingType) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *TargetingType) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_TargetingTypebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_TargetingTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_TargetingType_Age, kn) {
						currentKey = ffj_t_TargetingType_Age
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TargetingType_AppInstallStatus, kn) {
						currentKey = ffj_t_TargetingType_AppInstallStatus
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TargetingType_AppBehavior, kn) {
						currentKey = ffj_t_TargetingType_AppBehavior
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffj_key_TargetingType_BusinessInterest, kn) {
						currentKey = ffj_t_TargetingType_BusinessInterest
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_TargetingType_Climate, kn) {
						currentKey = ffj_t_TargetingType_Climate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TargetingType_CustomAudiences, kn) {
						currentKey = ffj_t_TargetingType_CustomAudiences
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_TargetingType_DevicePrice, kn) {
						currentKey = ffj_t_TargetingType_DevicePrice
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TargetingType_DressingIndex, kn) {
						currentKey = ffj_t_TargetingType_DressingIndex
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_TargetingType_Education, kn) {
						currentKey = ffj_t_TargetingType_Education
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TargetingType_ExcludedCustomAudiences, kn) {
						currentKey = ffj_t_TargetingType_ExcludedCustomAudiences
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_TargetingType_Gender, kn) {
						currentKey = ffj_t_TargetingType_Gender
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TargetingType_GeoLocation, kn) {
						currentKey = ffj_t_TargetingType_GeoLocation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_TargetingType_Keyword, kn) {
						currentKey = ffj_t_TargetingType_Keyword
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_TargetingType_LivingStatus, kn) {
						currentKey = ffj_t_TargetingType_LivingStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_TargetingType_MakeupIndex, kn) {
						currentKey = ffj_t_TargetingType_MakeupIndex
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_TargetingType_NewDevice, kn) {
						currentKey = ffj_t_TargetingType_NewDevice
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TargetingType_NetworkType, kn) {
						currentKey = ffj_t_TargetingType_NetworkType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TargetingType_NetworkOperator, kn) {
						currentKey = ffj_t_TargetingType_NetworkOperator
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_TargetingType_PlayerConsupt, kn) {
						currentKey = ffj_t_TargetingType_PlayerConsupt
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TargetingType_PayingUserType, kn) {
						currentKey = ffj_t_TargetingType_PayingUserType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_TargetingType_RelationshipStatus, kn) {
						currentKey = ffj_t_TargetingType_RelationshipStatus
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TargetingType_ResidentialCommunityPrice, kn) {
						currentKey = ffj_t_TargetingType_ResidentialCommunityPrice
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_TargetingType_ShoppingCapability, kn) {
						currentKey = ffj_t_TargetingType_ShoppingCapability
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_TargetingType_Temperature, kn) {
						currentKey = ffj_t_TargetingType_Temperature
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_TargetingType_UserOS, kn) {
						currentKey = ffj_t_TargetingType_UserOS
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TargetingType_UVIndex, kn) {
						currentKey = ffj_t_TargetingType_UVIndex
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_TargetingType_ExcludedCustomAudiences, kn) {
					currentKey = ffj_t_TargetingType_ExcludedCustomAudiences
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TargetingType_CustomAudiences, kn) {
					currentKey = ffj_t_TargetingType_CustomAudiences
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TargetingType_ResidentialCommunityPrice, kn) {
					currentKey = ffj_t_TargetingType_ResidentialCommunityPrice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TargetingType_PayingUserType, kn) {
					currentKey = ffj_t_TargetingType_PayingUserType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TargetingType_PlayerConsupt, kn) {
					currentKey = ffj_t_TargetingType_PlayerConsupt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TargetingType_ShoppingCapability, kn) {
					currentKey = ffj_t_TargetingType_ShoppingCapability
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_TargetingType_AppBehavior, kn) {
					currentKey = ffj_t_TargetingType_AppBehavior
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TargetingType_AppInstallStatus, kn) {
					currentKey = ffj_t_TargetingType_AppInstallStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TargetingType_Temperature, kn) {
					currentKey = ffj_t_TargetingType_Temperature
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TargetingType_Climate, kn) {
					currentKey = ffj_t_TargetingType_Climate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TargetingType_MakeupIndex, kn) {
					currentKey = ffj_t_TargetingType_MakeupIndex
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_TargetingType_UVIndex, kn) {
					currentKey = ffj_t_TargetingType_UVIndex
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TargetingType_DressingIndex, kn) {
					currentKey = ffj_t_TargetingType_DressingIndex
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TargetingType_NetworkOperator, kn) {
					currentKey = ffj_t_TargetingType_NetworkOperator
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TargetingType_NetworkType, kn) {
					currentKey = ffj_t_TargetingType_NetworkType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_TargetingType_DevicePrice, kn) {
					currentKey = ffj_t_TargetingType_DevicePrice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_TargetingType_NewDevice, kn) {
					currentKey = ffj_t_TargetingType_NewDevice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TargetingType_UserOS, kn) {
					currentKey = ffj_t_TargetingType_UserOS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_TargetingType_GeoLocation, kn) {
					currentKey = ffj_t_TargetingType_GeoLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TargetingType_Keyword, kn) {
					currentKey = ffj_t_TargetingType_Keyword
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TargetingType_BusinessInterest, kn) {
					currentKey = ffj_t_TargetingType_BusinessInterest
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TargetingType_LivingStatus, kn) {
					currentKey = ffj_t_TargetingType_LivingStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TargetingType_RelationshipStatus, kn) {
					currentKey = ffj_t_TargetingType_RelationshipStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TargetingType_Education, kn) {
					currentKey = ffj_t_TargetingType_Education
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TargetingType_Gender, kn) {
					currentKey = ffj_t_TargetingType_Gender
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TargetingType_Age, kn) {
					currentKey = ffj_t_TargetingType_Age
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_TargetingTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_TargetingType_Age:
					goto handle_Age

				case ffj_t_TargetingType_Gender:
					goto handle_Gender

				case ffj_t_TargetingType_Education:
					goto handle_Education

				case ffj_t_TargetingType_RelationshipStatus:
					goto handle_RelationshipStatus

				case ffj_t_TargetingType_LivingStatus:
					goto handle_LivingStatus

				case ffj_t_TargetingType_BusinessInterest:
					goto handle_BusinessInterest

				case ffj_t_TargetingType_Keyword:
					goto handle_Keyword

				case ffj_t_TargetingType_GeoLocation:
					goto handle_GeoLocation

				case ffj_t_TargetingType_UserOS:
					goto handle_UserOS

				case ffj_t_TargetingType_NewDevice:
					goto handle_NewDevice

				case ffj_t_TargetingType_DevicePrice:
					goto handle_DevicePrice

				case ffj_t_TargetingType_NetworkType:
					goto handle_NetworkType

				case ffj_t_TargetingType_NetworkOperator:
					goto handle_NetworkOperator

				case ffj_t_TargetingType_DressingIndex:
					goto handle_DressingIndex

				case ffj_t_TargetingType_UVIndex:
					goto handle_UVIndex

				case ffj_t_TargetingType_MakeupIndex:
					goto handle_MakeupIndex

				case ffj_t_TargetingType_Climate:
					goto handle_Climate

				case ffj_t_TargetingType_Temperature:
					goto handle_Temperature

				case ffj_t_TargetingType_AppInstallStatus:
					goto handle_AppInstallStatus

				case ffj_t_TargetingType_AppBehavior:
					goto handle_AppBehavior

				case ffj_t_TargetingType_ShoppingCapability:
					goto handle_ShoppingCapability

				case ffj_t_TargetingType_PlayerConsupt:
					goto handle_PlayerConsupt

				case ffj_t_TargetingType_PayingUserType:
					goto handle_PayingUserType

				case ffj_t_TargetingType_ResidentialCommunityPrice:
					goto handle_ResidentialCommunityPrice

				case ffj_t_TargetingType_CustomAudiences:
					goto handle_CustomAudiences

				case ffj_t_TargetingType_ExcludedCustomAudiences:
					goto handle_ExcludedCustomAudiences

				case ffj_t_TargetingTypeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Age:

	/* handler: uj.Age type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Age = nil
		} else {

			uj.Age = []string{}

			wantVal := true

			for {

				var tmp_uj__Age string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Age type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__Age = string(string(outBuf))

					}
				}

				uj.Age = append(uj.Age, tmp_uj__Age)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gender:

	/* handler: uj.Gender type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Gender = nil
		} else {

			uj.Gender = []string{}

			wantVal := true

			for {

				var tmp_uj__Gender string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Gender type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__Gender = string(string(outBuf))

					}
				}

				uj.Gender = append(uj.Gender, tmp_uj__Gender)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Education:

	/* handler: uj.Education type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Education = nil
		} else {

			uj.Education = []string{}

			wantVal := true

			for {

				var tmp_uj__Education string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Education type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__Education = string(string(outBuf))

					}
				}

				uj.Education = append(uj.Education, tmp_uj__Education)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RelationshipStatus:

	/* handler: uj.RelationshipStatus type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.RelationshipStatus = nil
		} else {

			uj.RelationshipStatus = []string{}

			wantVal := true

			for {

				var tmp_uj__RelationshipStatus string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__RelationshipStatus type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__RelationshipStatus = string(string(outBuf))

					}
				}

				uj.RelationshipStatus = append(uj.RelationshipStatus, tmp_uj__RelationshipStatus)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LivingStatus:

	/* handler: uj.LivingStatus type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.LivingStatus = nil
		} else {

			uj.LivingStatus = []string{}

			wantVal := true

			for {

				var tmp_uj__LivingStatus string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__LivingStatus type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__LivingStatus = string(string(outBuf))

					}
				}

				uj.LivingStatus = append(uj.LivingStatus, tmp_uj__LivingStatus)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BusinessInterest:

	/* handler: uj.BusinessInterest type=[]int64 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.BusinessInterest = nil
		} else {

			uj.BusinessInterest = []int64{}

			wantVal := true

			for {

				var tmp_uj__BusinessInterest int64

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__BusinessInterest type=int64 kind=int64 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmp_uj__BusinessInterest = int64(tval)

					}
				}

				uj.BusinessInterest = append(uj.BusinessInterest, tmp_uj__BusinessInterest)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Keyword:

	/* handler: uj.Keyword type=gdt.KeywordsType kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Keyword.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GeoLocation:

	/* handler: uj.GeoLocation type=gdt.GeoLocationType kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.GeoLocation.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserOS:

	/* handler: uj.UserOS type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.UserOS = nil
		} else {

			uj.UserOS = []string{}

			wantVal := true

			for {

				var tmp_uj__UserOS string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__UserOS type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__UserOS = string(string(outBuf))

					}
				}

				uj.UserOS = append(uj.UserOS, tmp_uj__UserOS)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewDevice:

	/* handler: uj.NewDevice type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.NewDevice = nil
		} else {

			uj.NewDevice = []string{}

			wantVal := true

			for {

				var tmp_uj__NewDevice string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__NewDevice type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__NewDevice = string(string(outBuf))

					}
				}

				uj.NewDevice = append(uj.NewDevice, tmp_uj__NewDevice)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DevicePrice:

	/* handler: uj.DevicePrice type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.DevicePrice = nil
		} else {

			uj.DevicePrice = []string{}

			wantVal := true

			for {

				var tmp_uj__DevicePrice string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__DevicePrice type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__DevicePrice = string(string(outBuf))

					}
				}

				uj.DevicePrice = append(uj.DevicePrice, tmp_uj__DevicePrice)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetworkType:

	/* handler: uj.NetworkType type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.NetworkType = nil
		} else {

			uj.NetworkType = []string{}

			wantVal := true

			for {

				var tmp_uj__NetworkType string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__NetworkType type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__NetworkType = string(string(outBuf))

					}
				}

				uj.NetworkType = append(uj.NetworkType, tmp_uj__NetworkType)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetworkOperator:

	/* handler: uj.NetworkOperator type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.NetworkOperator = nil
		} else {

			uj.NetworkOperator = []string{}

			wantVal := true

			for {

				var tmp_uj__NetworkOperator string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__NetworkOperator type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__NetworkOperator = string(string(outBuf))

					}
				}

				uj.NetworkOperator = append(uj.NetworkOperator, tmp_uj__NetworkOperator)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DressingIndex:

	/* handler: uj.DressingIndex type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.DressingIndex = nil
		} else {

			uj.DressingIndex = []string{}

			wantVal := true

			for {

				var tmp_uj__DressingIndex string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__DressingIndex type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__DressingIndex = string(string(outBuf))

					}
				}

				uj.DressingIndex = append(uj.DressingIndex, tmp_uj__DressingIndex)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UVIndex:

	/* handler: uj.UVIndex type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.UVIndex = nil
		} else {

			uj.UVIndex = []string{}

			wantVal := true

			for {

				var tmp_uj__UVIndex string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__UVIndex type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__UVIndex = string(string(outBuf))

					}
				}

				uj.UVIndex = append(uj.UVIndex, tmp_uj__UVIndex)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MakeupIndex:

	/* handler: uj.MakeupIndex type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.MakeupIndex = nil
		} else {

			uj.MakeupIndex = []string{}

			wantVal := true

			for {

				var tmp_uj__MakeupIndex string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__MakeupIndex type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__MakeupIndex = string(string(outBuf))

					}
				}

				uj.MakeupIndex = append(uj.MakeupIndex, tmp_uj__MakeupIndex)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Climate:

	/* handler: uj.Climate type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Climate = nil
		} else {

			uj.Climate = []string{}

			wantVal := true

			for {

				var tmp_uj__Climate string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Climate type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__Climate = string(string(outBuf))

					}
				}

				uj.Climate = append(uj.Climate, tmp_uj__Climate)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Temperature:

	/* handler: uj.Temperature type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Temperature = nil
		} else {

			uj.Temperature = []string{}

			wantVal := true

			for {

				var tmp_uj__Temperature string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Temperature type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__Temperature = string(string(outBuf))

					}
				}

				uj.Temperature = append(uj.Temperature, tmp_uj__Temperature)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppInstallStatus:

	/* handler: uj.AppInstallStatus type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.AppInstallStatus = nil
		} else {

			uj.AppInstallStatus = []string{}

			wantVal := true

			for {

				var tmp_uj__AppInstallStatus string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__AppInstallStatus type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__AppInstallStatus = string(string(outBuf))

					}
				}

				uj.AppInstallStatus = append(uj.AppInstallStatus, tmp_uj__AppInstallStatus)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppBehavior:

	/* handler: uj.AppBehavior type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.AppBehavior = nil
		} else {

			uj.AppBehavior = []string{}

			wantVal := true

			for {

				var tmp_uj__AppBehavior string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__AppBehavior type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__AppBehavior = string(string(outBuf))

					}
				}

				uj.AppBehavior = append(uj.AppBehavior, tmp_uj__AppBehavior)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShoppingCapability:

	/* handler: uj.ShoppingCapability type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.ShoppingCapability = nil
		} else {

			uj.ShoppingCapability = []string{}

			wantVal := true

			for {

				var tmp_uj__ShoppingCapability string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__ShoppingCapability type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__ShoppingCapability = string(string(outBuf))

					}
				}

				uj.ShoppingCapability = append(uj.ShoppingCapability, tmp_uj__ShoppingCapability)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PlayerConsupt:

	/* handler: uj.PlayerConsupt type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.PlayerConsupt = nil
		} else {

			uj.PlayerConsupt = []string{}

			wantVal := true

			for {

				var tmp_uj__PlayerConsupt string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__PlayerConsupt type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__PlayerConsupt = string(string(outBuf))

					}
				}

				uj.PlayerConsupt = append(uj.PlayerConsupt, tmp_uj__PlayerConsupt)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PayingUserType:

	/* handler: uj.PayingUserType type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.PayingUserType = nil
		} else {

			uj.PayingUserType = []string{}

			wantVal := true

			for {

				var tmp_uj__PayingUserType string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__PayingUserType type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__PayingUserType = string(string(outBuf))

					}
				}

				uj.PayingUserType = append(uj.PayingUserType, tmp_uj__PayingUserType)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ResidentialCommunityPrice:

	/* handler: uj.ResidentialCommunityPrice type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.ResidentialCommunityPrice = nil
		} else {

			uj.ResidentialCommunityPrice = []string{}

			wantVal := true

			for {

				var tmp_uj__ResidentialCommunityPrice string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__ResidentialCommunityPrice type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__ResidentialCommunityPrice = string(string(outBuf))

					}
				}

				uj.ResidentialCommunityPrice = append(uj.ResidentialCommunityPrice, tmp_uj__ResidentialCommunityPrice)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CustomAudiences:

	/* handler: uj.CustomAudiences type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.CustomAudiences = nil
		} else {

			uj.CustomAudiences = []string{}

			wantVal := true

			for {

				var tmp_uj__CustomAudiences string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__CustomAudiences type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__CustomAudiences = string(string(outBuf))

					}
				}

				uj.CustomAudiences = append(uj.CustomAudiences, tmp_uj__CustomAudiences)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExcludedCustomAudiences:

	/* handler: uj.ExcludedCustomAudiences type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.ExcludedCustomAudiences = nil
		} else {

			uj.ExcludedCustomAudiences = []string{}

			wantVal := true

			for {

				var tmp_uj__ExcludedCustomAudiences string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__ExcludedCustomAudiences type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__ExcludedCustomAudiences = string(string(outBuf))

					}
				}

				uj.ExcludedCustomAudiences = append(uj.ExcludedCustomAudiences, tmp_uj__ExcludedCustomAudiences)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *TokenData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *TokenData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"access_token":`)
	fflib.WriteJsonString(buf, string(mj.AccessToken))
	buf.WriteString(`,"refresh_token":`)
	fflib.WriteJsonString(buf, string(mj.RefreshToken))
	buf.WriteString(`,"access_token_expires_in":`)
	fflib.FormatBits2(buf, uint64(mj.AccessTokenExpiresIn), 10, mj.AccessTokenExpiresIn < 0)
	buf.WriteString(`,"refresh_token_expires_in":`)
	fflib.FormatBits2(buf, uint64(mj.RefreshTokenExpiresIn), 10, mj.RefreshTokenExpiresIn < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_TokenDatabase = iota
	ffj_t_TokenDatano_such_key

	ffj_t_TokenData_AccessToken

	ffj_t_TokenData_RefreshToken

	ffj_t_TokenData_AccessTokenExpiresIn

	ffj_t_TokenData_RefreshTokenExpiresIn
)

var ffj_key_TokenData_AccessToken = []byte("access_token")

var ffj_key_TokenData_RefreshToken = []byte("refresh_token")

var ffj_key_TokenData_AccessTokenExpiresIn = []byte("access_token_expires_in")

var ffj_key_TokenData_RefreshTokenExpiresIn = []byte("refresh_token_expires_in")

func (uj *TokenData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *TokenData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_TokenDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_TokenDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_TokenData_AccessToken, kn) {
						currentKey = ffj_t_TokenData_AccessToken
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TokenData_AccessTokenExpiresIn, kn) {
						currentKey = ffj_t_TokenData_AccessTokenExpiresIn
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_TokenData_RefreshToken, kn) {
						currentKey = ffj_t_TokenData_RefreshToken
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TokenData_RefreshTokenExpiresIn, kn) {
						currentKey = ffj_t_TokenData_RefreshTokenExpiresIn
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_TokenData_RefreshTokenExpiresIn, kn) {
					currentKey = ffj_t_TokenData_RefreshTokenExpiresIn
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TokenData_AccessTokenExpiresIn, kn) {
					currentKey = ffj_t_TokenData_AccessTokenExpiresIn
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TokenData_RefreshToken, kn) {
					currentKey = ffj_t_TokenData_RefreshToken
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TokenData_AccessToken, kn) {
					currentKey = ffj_t_TokenData_AccessToken
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_TokenDatano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_TokenData_AccessToken:
					goto handle_AccessToken

				case ffj_t_TokenData_RefreshToken:
					goto handle_RefreshToken

				case ffj_t_TokenData_AccessTokenExpiresIn:
					goto handle_AccessTokenExpiresIn

				case ffj_t_TokenData_RefreshTokenExpiresIn:
					goto handle_RefreshTokenExpiresIn

				case ffj_t_TokenDatano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AccessToken:

	/* handler: uj.AccessToken type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AccessToken = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RefreshToken:

	/* handler: uj.RefreshToken type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.RefreshToken = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AccessTokenExpiresIn:

	/* handler: uj.AccessTokenExpiresIn type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.AccessTokenExpiresIn = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RefreshTokenExpiresIn:

	/* handler: uj.RefreshTokenExpiresIn type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.RefreshTokenExpiresIn = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *TokenResponse) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *TokenResponse) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"code":`)
	fflib.FormatBits2(buf, uint64(mj.Code), 10, mj.Code < 0)
	buf.WriteString(`,"message":`)
	fflib.WriteJsonString(buf, string(mj.Message))
	buf.WriteString(`,"data":`)

	{

		err = mj.Data.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_TokenResponsebase = iota
	ffj_t_TokenResponseno_such_key

	ffj_t_TokenResponse_Code

	ffj_t_TokenResponse_Message

	ffj_t_TokenResponse_Data
)

var ffj_key_TokenResponse_Code = []byte("code")

var ffj_key_TokenResponse_Message = []byte("message")

var ffj_key_TokenResponse_Data = []byte("data")

func (uj *TokenResponse) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *TokenResponse) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_TokenResponsebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_TokenResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_TokenResponse_Code, kn) {
						currentKey = ffj_t_TokenResponse_Code
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_TokenResponse_Data, kn) {
						currentKey = ffj_t_TokenResponse_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_TokenResponse_Message, kn) {
						currentKey = ffj_t_TokenResponse_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_TokenResponse_Data, kn) {
					currentKey = ffj_t_TokenResponse_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TokenResponse_Message, kn) {
					currentKey = ffj_t_TokenResponse_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TokenResponse_Code, kn) {
					currentKey = ffj_t_TokenResponse_Code
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_TokenResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_TokenResponse_Code:
					goto handle_Code

				case ffj_t_TokenResponse_Message:
					goto handle_Message

				case ffj_t_TokenResponse_Data:
					goto handle_Data

				case ffj_t_TokenResponseno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Code:

	/* handler: uj.Code type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Code = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=gdt.TokenData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Data.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *VideoPopupButtonType) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *VideoPopupButtonType) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"video_popup_button_text":`)
	fflib.WriteJsonString(buf, string(mj.VideoPopupButtonText))
	buf.WriteString(`,"video_popup_button_url":`)
	fflib.WriteJsonString(buf, string(mj.VideoPopupButtonUrl))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_VideoPopupButtonTypebase = iota
	ffj_t_VideoPopupButtonTypeno_such_key

	ffj_t_VideoPopupButtonType_VideoPopupButtonText

	ffj_t_VideoPopupButtonType_VideoPopupButtonUrl
)

var ffj_key_VideoPopupButtonType_VideoPopupButtonText = []byte("video_popup_button_text")

var ffj_key_VideoPopupButtonType_VideoPopupButtonUrl = []byte("video_popup_button_url")

func (uj *VideoPopupButtonType) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *VideoPopupButtonType) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_VideoPopupButtonTypebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_VideoPopupButtonTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_VideoPopupButtonType_VideoPopupButtonText, kn) {
						currentKey = ffj_t_VideoPopupButtonType_VideoPopupButtonText
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_VideoPopupButtonType_VideoPopupButtonUrl, kn) {
						currentKey = ffj_t_VideoPopupButtonType_VideoPopupButtonUrl
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_VideoPopupButtonType_VideoPopupButtonUrl, kn) {
					currentKey = ffj_t_VideoPopupButtonType_VideoPopupButtonUrl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_VideoPopupButtonType_VideoPopupButtonText, kn) {
					currentKey = ffj_t_VideoPopupButtonType_VideoPopupButtonText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_VideoPopupButtonTypeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_VideoPopupButtonType_VideoPopupButtonText:
					goto handle_VideoPopupButtonText

				case ffj_t_VideoPopupButtonType_VideoPopupButtonUrl:
					goto handle_VideoPopupButtonUrl

				case ffj_t_VideoPopupButtonTypeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_VideoPopupButtonText:

	/* handler: uj.VideoPopupButtonText type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.VideoPopupButtonText = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoPopupButtonUrl:

	/* handler: uj.VideoPopupButtonUrl type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.VideoPopupButtonUrl = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
